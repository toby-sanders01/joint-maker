<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Truss Joint Diagram Generator</title>
<style>
  :root{
    --bg:#fdfefe;
    --panel:#ffffff;
    --muted:#5b6374;
    --text:#0d1b2a;
    --accent:#2f3fcf;
    --green:#2e7d32;
    --blue:#1e88e5;
    --red:#c62828;
    --gray:#7a7f8d;
    --border:#e3e6f0;
    --shadow:0 16px 60px rgba(9,21,54,.08);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font:15px/1.6 "Helvetica Neue", Arial, sans-serif;
    min-height:100vh;
    display:flex;
    flex-direction:column;
    align-items:stretch;
  }
  header{
    padding:16px 22px;
    display:flex;
    gap:10px 12px;
    flex-wrap:wrap;
    align-items:center;
    justify-content:space-between;
    border-bottom:1px solid var(--border);
    background:#fff;
    position:sticky; top:0; z-index:5;
    box-shadow:0 10px 30px rgba(0,0,0,.04);
  }
  header h1{
    margin:0;
    font-weight:800;
    font-size:19px;
    letter-spacing:.2px;
    display:flex;
    align-items:center;
    gap:10px;
  }
  .badge{
    font-size:11px;
    padding:4px 8px;
    border-radius:999px;
    background:#eef1ff;
    color:#2f3fcf;
    border:1px solid #dbe0ff;
  }
  .btnbar{display:flex; gap:10px; flex-wrap:wrap}
  button{
    background:var(--accent);
    color:#fff;
    border:1px solid #2634a4;
    padding:10px 14px;
    border-radius:10px;
    cursor:pointer;
    font-weight:700;
    transition:transform .08s ease, box-shadow .15s ease;
    box-shadow:0 8px 20px rgba(47,63,207,.18);
  }
  button:hover{transform:translateY(-1px); box-shadow:0 12px 24px rgba(47,63,207,.18);}
  .ghost{background:#f7f8ff; color:#1a265f; border-color:#d4d9ff; box-shadow:none}
  .subtle{background:#f8fafc; color:#102047; border-color:var(--border); box-shadow:none}
  main{
    display:grid;
    grid-template-columns: clamp(700px, 48vw, 880px) 1fr;
    gap:18px;
    padding:24px;
    width:100%;
    max-width:1680px;
    margin:0 auto;
    flex:1;
  }
  @media (max-width: 1100px){
    main{grid-template-columns: 1fr; }
  }
  .panel{
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow: var(--shadow);
  }
  .controls{ padding:18px; display:flex; flex-direction:column; gap:14px; min-width:680px;}
  label{display:block; font-weight:800; margin-bottom:6px; letter-spacing:.1px;}
  input[type="text"], input[type="number"], select, textarea{
    width:100%;
    background:#fff;
    border:1px solid var(--border);
    color:#1b2235;
    border-radius:12px;
    padding:10px 12px;
    outline:none;
    font:14px/1.4 "Helvetica Neue", Arial, sans-serif;
  }
  textarea{min-height:120px; resize:vertical;}
  input[type="text"]::placeholder, input[type="number"]::placeholder, textarea::placeholder{color:#9aa0af}
  .row{
    display:grid;
    grid-template-columns: 160px 210px 240px 170px 56px;
    gap:10px; align-items:end;
  }
  .head{grid-template-columns: 160px 210px 240px 170px 56px;}
  .muted{color:var(--muted); font-size:13px}
  .canvas-wrap{position:relative; padding:16px; background:linear-gradient(180deg, #fff, #f8fbff);}
  canvas{width:100%; height:auto; border-radius:12px; background:#ffffff; border:1px solid var(--border)}
  .legend{display:flex; gap:14px; padding:12px 14px; border-top:1px solid var(--border); color:#333; font-size:13px; background:#fbfcff; border-radius:0 0 14px 14px}
  .chip{display:inline-flex; align-items:center; gap:6px}
  .sw{width:14px; height:4px; border-radius:2px; background:var(--gray); display:inline-block}
  .sw.green{background:var(--green)}
  .sw.blue{background:var(--blue)}
  .sw.red{background:var(--red)}
  .sw.gray{background:#8a8f9e}
  .member-card{padding:12px; border:1px dashed var(--border); border-radius:12px; background:#f8faff}
  .delete{
    padding:10px 0; text-align:center; border-radius:8px;
    background:#f4f6ff; border:1px solid #d6dcff; color:#2f3f8c; font-weight:700;
    box-shadow:none;
  }
  .delete:hover{background:#e8edff}
  .quickdir{display:grid; grid-template-columns: repeat(8, 1fr); gap:4px; margin-top:6px;}
  .dirbtn{
    padding:6px 0;
    border-radius:8px;
    border:1px solid var(--border);
    background:#fff;
    color:#2a2f3b;
    cursor:pointer;
    font-size:14px;
    line-height:1;
  }
  .tip{color:#5b6788; font-size:12px}
  .truss-bar{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
  .joint-tabs{display:flex; gap:8px; flex-wrap:wrap;}
  .joint-chip{
    padding:8px 12px;
    border-radius:12px;
    border:1px solid var(--border);
    background:#fff;
    color:#13244f;
    cursor:pointer;
    font-weight:700;
  }
  .joint-chip.active{background:#eef1ff; color:#1c2e92; border-color:#cfd6ff;}
  .stack{display:flex; flex-direction:column; gap:10px;}
  .structure-card{border:1px dashed var(--border); padding:12px; border-radius:12px; background:#fdfdff;}
  .inline-actions{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
</style>
</head>
<body>
  <header>
    <h1>Truss Joint Diagram <span class="badge">single-file app</span></h1>
    <div class="btnbar">
      <button id="exportJpegBtn" title="Download cropped JPEG (high-res)">Export JPEG</button>
      <button id="exportSvgBtn" class="ghost" title="Download cropped SVG">Export SVG</button>
      <button id="exportZipBtn" class="ghost" title="Download every joint as a ZIP">Export ZIP</button>
      <button id="clearBtn" class="ghost" title="Clear all members">Clear</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <div class="controls">
        <div>
          <label for="jointName">Joint name</label>
          <input id="jointName" type="text" placeholder="A" maxlength="6" />
          <div class="tip">Names are auto-uppercased. The diagram updates as you type.</div>
        </div>

        <div class="stack">
          <label>Truss workspace</label>
          <div class="truss-bar">
            <div id="jointTabs" class="joint-tabs"></div>
            <button id="addJointBtn" class="ghost" title="Add another joint to this truss">+ Joint</button>
          </div>
          <div class="structure-card">
            <label for="structureText" style="margin:0;">Full truss structure</label>
            <textarea id="structureText" placeholder="A,AB,0,Tension,50
A,AC,45,Compression,30
B,BA,180,Reaction,18"></textarea>
            <div class="muted">Enter one member per line as <b>Joint, Member, Direction°, Sense, Magnitude</b>. Sense can be blank. JSON arrays of joints are also supported.</div>
            <div class="inline-actions">
              <button id="applyStructureBtn" class="subtle">Apply structure</button>
              <button id="importFileBtn" class="ghost" title="Import structure from JSON/CSV">Batch import file</button>
              <input type="file" id="importFile" accept=".json,.csv,.txt" style="display:none" />
            </div>
          </div>
        </div>

        <div class="member-card">
          <div class="row head" style="font-weight:700; color:#1b2344;">
            <div>Member name</div>
            <div>Direction (°)</div>
            <div>Type / Sense</div>
            <div>Magnitude (kN)</div>
            <div>&nbsp;</div>
          </div>

          <div id="members" style="display:flex; flex-direction:column; gap:10px;"></div>

          <div style="margin-top:8px">
            <button id="addMemberBtn">+ Member</button>
          </div>
        </div>

        <div class="muted">
          • <b>Tension</b> = arrow points away from the joint (green).<br/>
          • <b>Compression</b> = arrow points toward the joint (blue).<br/>
          • <b>Reaction</b> = arrow points toward the joint (red).
        </div>
      </div>
    </section>

    <section class="panel canvas-wrap">
      <canvas id="cnv" width="1400" height="950" aria-label="diagram canvas"></canvas>
      <div class="legend">
        <span class="chip"><span class="sw green"></span> Tension</span>
        <span class="chip"><span class="sw blue"></span> Compression</span>
        <span class="chip"><span class="sw red"></span> Reaction</span>
        <span class="chip"><span class="sw gray"></span> Direction only</span>
      </div>
    </section>
  </main>

<script>
(() => {
  const $ = (sel, el=document) => el.querySelector(sel);
  const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

  const cnv = $('#cnv');
  const ctx = cnv.getContext('2d');
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  function fitCanvas() {
    const w = cnv.clientWidth;
    const h = cnv.clientHeight;
    cnv.width = Math.round(w * DPR);
    cnv.height = Math.round(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    draw();
  }
  new ResizeObserver(fitCanvas).observe(cnv);

  const membersWrap = $('#members');
  const addMemberBtn = $('#addMemberBtn');
  const exportJpegBtn = $('#exportJpegBtn');
  const exportSvgBtn = $('#exportSvgBtn');
  const exportZipBtn = $('#exportZipBtn');
  const clearBtn = $('#clearBtn');
  const jointInput = $('#jointName');
  const jointTabs = $('#jointTabs');
  const addJointBtn = $('#addJointBtn');
  const structureText = $('#structureText');
  const applyStructureBtn = $('#applyStructureBtn');
  const importFileBtn = $('#importFileBtn');
  const importFileInput = $('#importFile');

  const truss = new Map();
  let currentJoint = 'A';
  let memberId = 0;
  let lastRender = null; // geometry and bbox for exports

  function updateJointTabs(){
    jointTabs.innerHTML = '';
    for(const [name] of truss){
      const btn = document.createElement('button');
      btn.className = 'joint-chip' + (name === currentJoint ? ' active' : '');
      btn.textContent = name;
      btn.title = `Switch to joint ${name}`;
      btn.addEventListener('click', () => switchJoint(name));
      jointTabs.appendChild(btn);
    }
  }

  function saveCurrentJoint(){
    const members = getMembers();
    truss.set(currentJoint, members);
  }

  function clearMembersDom(){
    membersWrap.innerHTML = '';
    memberId = 0;
  }

  function loadMembers(list){
    clearMembersDom();
    if(!list || !list.length){
      makeMemberRow({});
      return;
    }
    list.forEach(m => makeMemberRow(m));
  }

  function switchJoint(name){
    const target = sanitizeJointName(name);
    saveCurrentJoint();
    currentJoint = target;
    jointInput.value = target;
    loadMembers(truss.get(target));
    updateJointTabs();
    draw();
  }

  function addJoint(name=''){ 
    const clean = sanitizeJointName(name || `J${truss.size+1}`);
    if(!truss.has(clean)){
      truss.set(clean, []);
    }
    switchJoint(clean);
  }

  function resetToSingleJoint(){
    truss.clear();
    currentJoint = 'A';
    truss.set(currentJoint, []);
    jointInput.value = currentJoint;
    loadMembers([]);
    updateJointTabs();
    draw();
  }

  function sanitizeJointName(name){
    const val = (name || '').trim().toUpperCase().slice(0, 6) || 'A';
    return val;
  }

  function makeMemberRow(init={}){
    memberId += 1;
    const id = memberId;
    const row = document.createElement('div');
    row.className = 'row';
    row.dataset.id = id;
    row.innerHTML = `
      <div>
        <input type="text" class="memName" placeholder="AB" value="${init.name||''}" />
      </div>
      <div>
        <input type="number" step="0.1" min="0" max="360" class="dir" placeholder="0 → right" value="${init.dir??''}" />
        <div class="quickdir">
          <button class="dirbtn" data-deg="0" title="Right">→</button>
          <button class="dirbtn" data-deg="45" title="NE">↗</button>
          <button class="dirbtn" data-deg="90" title="Up">↑</button>
          <button class="dirbtn" data-deg="135" title="NW">↖</button>
          <button class="dirbtn" data-deg="180" title="Left">←</button>
          <button class="dirbtn" data-deg="225" title="SW">↙</button>
          <button class="dirbtn" data-deg="270" title="Down">↓</button>
          <button class="dirbtn" data-deg="315" title="SE">↘</button>
        </div>
      </div>
      <div>
        <select class="sense">
          <option value="">— direction only —</option>
          <option value="Tension">Tension (green)</option>
          <option value="Compression">Compression (blue)</option>
          <option value="Reaction">Reaction (red)</option>
        </select>
      </div>
      <div>
        <input type="number" step="0.01" class="mag" placeholder="e.g., 64.94" value="${init.mag??''}" />
      </div>
      <div>
        <button class="delete" title="Remove this member">✕</button>
      </div>
    `;

    row.addEventListener('input', draw);
    row.addEventListener('change', draw);
    row.querySelectorAll('.dirbtn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        row.querySelector('.dir').value = btn.dataset.deg;
        draw();
      });
    });
    row.querySelector('.delete').addEventListener('click', (e) => {
      e.preventDefault();
      row.remove();
      draw();
    });

    membersWrap.appendChild(row);
    draw();
  }

  function getMembers(){
    const joint = sanitizeJointName(jointInput.value || currentJoint);
    return $$('.row', membersWrap).map(row => {
      const name = $('.memName', row).value.trim().toUpperCase();
      const dirVal = $('.dir', row).value;
      const dir = dirVal === '' ? null : parseFloat(dirVal);
      const sense = $('.sense', row).value;
      const magStr = $('.mag', row).value.trim();
      const mag = magStr === '' ? null : parseFloat(magStr);
      return { name, dir: (dir!==null && Number.isFinite(dir)) ? dir : null, sense, mag, magStr, joint };
    });
  }

  function parseStructure(text){
    const res = new Map();
    const raw = (text || '').trim();
    if(!raw) return res;
    try{
      const data = JSON.parse(raw);
      if(Array.isArray(data)){
        for(const entry of data){
          const j = sanitizeJointName(entry.joint || entry.name || '');
          if(!j) continue;
          const members = Array.isArray(entry.members) ? entry.members.map(m => ({
            name:(m.name||'').toString().toUpperCase(),
            dir: m.dir===null||m.dir===undefined?null:Number(m.dir),
            sense: m.sense||m.type||'',
            mag: m.mag===null||m.mag===undefined?null:Number(m.mag),
            magStr: m.mag===null||m.mag===undefined? '': String(m.mag)
          })) : [];
          res.set(j, members);
        }
      }
      if(res.size) return res;
    }catch(e){ /* fall back to line parser */ }

    const lines = raw.split(/\r?\n/);
    for(const line of lines){
      const clean = line.trim();
      if(!clean || clean.startsWith('#')) continue;
      const parts = clean.split(/[,;\t]/).map(p=>p.trim());
      if(parts.length < 2) continue;
      const [jRaw, nameRaw, dirRaw, senseRaw, magRaw] = parts;
      const joint = sanitizeJointName(jRaw);
      if(!joint) continue;
      const members = res.get(joint) || [];
      const dir = dirRaw === '' || dirRaw === undefined ? null : Number(dirRaw);
      const mag = magRaw === '' || magRaw === undefined ? null : Number(magRaw);
      members.push({
        name:(nameRaw||'').toUpperCase(),
        dir: Number.isFinite(dir)?dir:null,
        sense: senseRaw || '',
        mag: Number.isFinite(mag)?mag:null,
        magStr: (magRaw??'').toString(),
        joint
      });
      res.set(joint, members);
    }
    return res;
  }

  function applyStructure(res){
    if(!res || !res.size) return;
    saveCurrentJoint();
    truss.clear();
    for(const [j, members] of res){
      truss.set(sanitizeJointName(j), members);
    }
    const first = res.keys().next().value || 'A';
    switchJoint(first);
  }

  function clearCanvas(){
    const w = cnv.width / DPR;
    const h = cnv.height / DPR;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,cnv.width,cnv.height);
    ctx.restore();
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,w,h);
  }

  // geometry helpers
  function expandBBox(b, x, y){ b.minX = Math.min(b.minX, x); b.minY = Math.min(b.minY, y); b.maxX = Math.max(b.maxX, x); b.maxY = Math.max(b.maxY, y); }
  function expandRect(b, cx, cy, w, h, rot){
    const hw = w/2, hh = h/2;
    const c = Math.cos(-rot||0), s = Math.sin(-rot||0);
    const pts = [[-hw,-hh],[hw,-hh],[hw,hh],[-hw,hh]];
    for(const [dx,dy] of pts){
      const x = cx + c*dx - s*dy;
      const y = cy + s*dx + c*dy;
      expandBBox(b, x, y);
    }
  }

  function drawArrow(x1,y1,x2,y2, color, headAtEnd=true, b=null, c=ctx){
    // line
    c.strokeStyle = color;
    c.lineWidth = 3;
    c.lineCap = 'round';
    c.beginPath();
    c.moveTo(x1,y1);
    c.lineTo(x2,y2);
    c.stroke();
    if(b){ expandBBox(b, x1, y1); expandBBox(b, x2, y2); }
    // arrow head (larger)
    const ang = Math.atan2(y2 - y1, x2 - x1);
    const size = 14;
    const hx = headAtEnd ? x2 : x1;
    const hy = headAtEnd ? y2 : y1;
    const theta = headAtEnd ? ang : ang + Math.PI;

    c.beginPath();
    c.moveTo(hx, hy);
    const p1 = [hx - size * Math.cos(theta - Math.PI/7), hy - size * Math.sin(theta - Math.PI/7)];
    const p2 = [hx - size * Math.cos(theta + Math.PI/7), hy - size * Math.sin(theta + Math.PI/7)];
    c.lineTo(...p1);
    c.lineTo(...p2);
    c.closePath();
    c.fillStyle = color;
    c.fill();
    if(b){ expandBBox(b, hx, hy); expandBBox(b, p1[0], p1[1]); expandBBox(b, p2[0], p2[1]); }
  }

  function distancePointToSegment(px,py, x1,y1,x2,y2){
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A*C + B*D;
    const len_sq = C*C + D*D;
    let param = -1;
    if (len_sq !== 0) param = dot / len_sq;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function measure(text, font){
    ctx.save();
    ctx.font = font;
    const w = ctx.measureText(text).width;
    ctx.restore();
    return {w, h: 16};
  }

  function projAlong(px,py, x1,y1, ux,uy){
    return ( (px - x1) * ux + (py - y1) * uy );
  }

  function draw(){
    clearCanvas();
    const w = cnv.width / DPR;
    const h = cnv.height / DPR;
    const cx = Math.round(w*0.62);
    const cy = Math.round(h*0.50);

    const joint = sanitizeJointName(jointInput.value || currentJoint);
    jointInput.value = joint;
    const L = Math.min(w,h) * 0.28;

    const style = getComputedStyle(document.documentElement);
    const colors = {
      'Tension': style.getPropertyValue('--green').trim(),
      'Compression': style.getPropertyValue('--blue').trim(),
      'Reaction': style.getPropertyValue('--red').trim(),
      'Guide': '#8a8f9e'
    };

    const members = getMembers();

    const segments = []; // for exports
    const labels = [];   // for exports
    const bbox = {minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity};

    const END_MARGIN = 24; // min distance of magnitude text from both ends

    function rectHitsPlaced(x,y,tw,th){
      const r = Math.hypot(tw, th) * 0.48;
      for(const p of labels){
        const rp = Math.hypot(p.tw, p.th) * 0.48;
        const d = Math.hypot(x - p.x, y - p.y);
        if(d < r + rp + 2) return true;
      }
      return false;
    }
    function candidateHitsSegments(x,y,tw,th, angle, along, allowOverlap){
      if(allowOverlap) return false; // allow over-the-line for magnitudes
      for(const s of segments){
        const d = distancePointToSegment(x, y, s.x1, s.y1, s.x2, s.y2);
        const threshold = along ? Math.max(th/2 + 8, 14) : Math.max(Math.hypot(tw,th)*0.50, 9);
        if(d < threshold) return true;
      }
      return false;
    }
    function tooCloseToEnds(x,y,tw,th, seg){
      const half = tw/2;
      const pr = projAlong(x,y, seg.x1, seg.y1, seg.ux, seg.uy);
      return (pr - half) < END_MARGIN || (pr + half) > (seg.L - END_MARGIN);
    }

    function putNearPoint(text, baseX, baseY, opts={}){
      const font = `${opts.size||16}px "Times New Roman", Times, serif`;
      const m = measure(text, font);
      const tw = m.w, th = m.h;
      const radii = opts.radii || [0,2,4,6,8,12,16];
      const dirs = opts.dirs || [0,45,90,135,180,225,270,315];
      for(const r of radii){
        for(const d of dirs){
          const a = d*Math.PI/180;
          const x = baseX + r*Math.cos(a);
          const y = baseY - r*Math.sin(a);
          if(!candidateHitsSegments(x,y,tw,th, 0, false, false) && !rectHitsPlaced(x,y,tw,th)){
            const obj = {x,y,tw,th,rot:0, color:opts.color||'#000', font, text, alpha: 1, halo:false};
            labels.push(obj);
            expandRect(bbox, obj.x, obj.y, tw+4, th+4, obj.rot);
            return obj;
          }
        }
      }
      const obj = {x:baseX,y:baseY,tw,th,rot:0, color:opts.color||'#000', font, text, alpha: 1, halo:false};
      labels.push(obj);
      expandRect(bbox, obj.x, obj.y, tw+4, th+4, obj.rot);
      return obj;
    }

    function putLabel(text, baseX, baseY, opts={angle:0, color:'#000', size:16, alignAlong:false, nearPoint:false, seg:null, minNormal:null, halo:false, alpha:1, overLine:false}){
      if(opts.nearPoint) return putNearPoint(text, baseX, baseY, opts);
      const font = `${opts.size||16}px "Times New Roman", Times, serif`;
      const m = measure(text, font);
      const tw = m.w, th = m.h;

      const tries = [];
      if(opts.alignAlong){
        const ang = opts.angle || 0;
        const ux = Math.cos(ang), uy = Math.sin(ang);
        const nx = -Math.sin(ang), ny = Math.cos(ang);
        const minP = Math.max(opts.minNormal ?? 0, 0); // allow being on the line
        for(let p=minP; p<=minP+8; p+=2){       // stay right on or near the line
          for(let s=0; s<=36; s+=6){            // small slides along
            tries.push([baseX + ux*s + nx*p, baseY - uy*s + ny*p, ang, true]);
            if(s>0) tries.push([baseX - ux*s + nx*p, baseY + uy*s + ny*p, ang, true]);
          }
        }
      }else{
        const radii = [0,2,4,6,8,12];
        const dirs = [0,45,90,135,180,225,270,315];
        for(const r of radii){
          for(const d of dirs){
            const a = d*Math.PI/180;
            tries.push([baseX + r*Math.cos(a), baseY - r*Math.sin(a), 0, false]);
          }
        }
      }
      for(const [x,y,rot,along] of tries){
        if(opts.seg && along && tooCloseToEnds(x,y,tw,th, opts.seg)) continue;
        if(!candidateHitsSegments(x,y,tw,th, rot, along, opts.overLine) && !rectHitsPlaced(x,y,tw,th)){
          const obj = {x,y,tw,th,rot, color:opts.color, font, text, halo: !!opts.halo, alpha: opts.alpha ?? 1};
          labels.push(obj);
          const haloPad = obj.halo ? 4 : 0;
          expandRect(bbox, obj.x, obj.y, tw+haloPad, th+haloPad, obj.rot);
          return obj;
        }
      }
      const obj = {x:baseX,y:baseY,tw,th,rot:opts.angle||0, color:opts.color, font, text, halo: !!opts.halo, alpha: opts.alpha ?? 1};
      labels.push(obj);
      const haloPad = obj.halo ? 4 : 0;
      expandRect(bbox, obj.x, obj.y, tw+haloPad, th+haloPad, obj.rot);
      return obj;
    }

    // Draw members and labels
    const JOINT = {x: cx, y: cy};
    for(const m of members){
      if(m.dir === null) continue;
      const rad = (m.dir % 360) * Math.PI/180;
      const x2 = cx + L*Math.cos(rad);
      const y2 = cy - L*Math.sin(rad);
      const ux = Math.cos(rad), uy = -Math.sin(rad); // canvas y inverted
      const nx = -Math.sin(rad), ny = Math.cos(rad);

      const seg = {x1:cx, y1:cy, x2, y2, ux, uy, L, color:colors[m.sense] || '#8a8f9e', dashed: !m.sense, headAtEnd: !(m.sense === 'Compression' || m.sense === 'Reaction')};

      // store for export
      segments.push(seg);

      // draw
      if(!m.sense){
        ctx.strokeStyle = 'rgba(120,120,130,.5)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6,6]);
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.lineTo(x2,y2);
        ctx.stroke();
        ctx.setLineDash([]);
        expandBBox(bbox, cx, cy); expandBBox(bbox, x2, y2);
      } else {
        drawArrow(cx, cy, x2, y2, seg.color, seg.headAtEnd, bbox);
      }

      // Far-end node letter
      const name = (m.name||'').replace(/[^A-Z]/g,'').toUpperCase();
      if(name){
        const letters = name.split('');
        const other = letters.find(ch => ch !== m.joint) || name;
        const tipx = cx + L*ux, tipy = cy + L*uy;
        const fx = tipx + nx*10;
        const fy = tipy + ny*10;
        putLabel(other, fx, fy, {size:16, color:'#000', nearPoint:true});
      }

      // Magnitude label (over the line)
      if(m.magStr && m.magStr.length && m.sense){
        const frac = 0.62;
        const base = { x: cx + (L*frac)*ux, y: cy + (L*frac)*uy };
        const obj = putLabel(`${m.magStr} kN`, base.x, base.y, {
          angle: rad,
          color: colors[m.sense],
          size: 16,
          alignAlong: true,
          seg,
          overLine: true,
          halo: true,
          alpha: 0.92
        });
        obj.rot = (Math.cos(rad) < 0) ? (rad + Math.PI) : rad;
      }
    }

    // Joint node + label
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI*2);
    ctx.fill();
    expandBBox(bbox, cx-4, cy-4); expandBBox(bbox, cx+4, cy+4);

    putNearPoint((joint||'A'), cx, cy, {
      size:16, color:'#000',
      radii:[8,10,12,14,16,18,20],
      dirs:[0,45,315,90,270,135,225,180]
    });

    // Render labels on top
    for(const p of labels){
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(-(p.rot || 0));
      ctx.font = p.font || '16px "Times New Roman", Times, serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if(p.halo){
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#ffffff';
        ctx.strokeText(p.text, 0, 0);
      }
      ctx.globalAlpha = p.alpha ?? 1;
      ctx.fillStyle = p.color || '#000';
      ctx.fillText(p.text, 0, 0);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Save render info for exports
    const PAD = 12;
    const minX = Math.max(0, Math.floor(bbox.minX - PAD));
    const minY = Math.max(0, Math.floor(bbox.minY - PAD));
    const maxX = Math.min(w, Math.ceil(bbox.maxX + PAD));
    const maxY = Math.min(h, Math.ceil(bbox.maxY + PAD));
    lastRender = {
      width: w, height: h, bbox:{x:minX,y:minY,w:Math.max(4,maxX-minX),h:Math.max(4,maxY-minY)},
      segments, labels, joint: JOINT, colors
    };
  }

  // ----- EXPORTS -----
  function downloadDataURI(name, dataURI){
    const link = document.createElement('a');
    link.download = name;
    link.href = dataURI;
    document.body.appendChild(link);
    link.click();
    link.remove();
  }

  function renderJpegDataURI(name){
    const safeName = (name || 'joint').trim() || 'joint';
    if(!lastRender){ draw(); }
    const SCALE = 4; // 4x size
    const {bbox, segments, labels, joint} = lastRender;

    const off = document.createElement('canvas');
    const PX = Math.max(1, Math.round(bbox.w * SCALE * DPR));
    const PY = Math.max(1, Math.round(bbox.h * SCALE * DPR));
    off.width = PX; off.height = PY;
    const c = off.getContext('2d');
    c.fillStyle = '#ffffff';
    c.fillRect(0,0,PX,PY);
    c.setTransform(DPR*SCALE, 0, 0, DPR*SCALE, -bbox.x*DPR*SCALE, -bbox.y*DPR*SCALE);

    c.lineCap = 'round';
    for(const s of segments){
      if(s.dashed){
        c.strokeStyle = 'rgba(120,120,130,.5)';
        c.lineWidth = 1.5;
        c.setLineDash([6,6]);
        c.beginPath();
        c.moveTo(s.x1,s.y1);
        c.lineTo(s.x2,s.y2);
        c.stroke();
        c.setLineDash([]);
      }else{
        drawArrow(s.x1,s.y1,s.x2,s.y2, s.color, s.headAtEnd, null, c);
      }
    }
    c.fillStyle = '#000';
    c.beginPath();
    c.arc(joint.x, joint.y, 4, 0, Math.PI*2);
    c.fill();

    for(const p of labels){
      c.save();
      c.translate(p.x, p.y);
      c.rotate(-(p.rot || 0));
      const fontSize = /(\d+)px/.exec(p.font||'16px')?.[1] || 16;
      c.font = `${fontSize}px "Times New Roman", Times, serif`;
      c.textAlign = 'center';
      c.textBaseline = 'middle';
      if(p.halo){
        c.lineWidth = 4;
        c.strokeStyle = '#ffffff';
        c.strokeText(p.text, 0, 0);
      }
      c.globalAlpha = p.alpha ?? 1;
      c.fillStyle = p.color || '#000';
      c.fillText(p.text, 0, 0);
      c.globalAlpha = 1;
      c.restore();
    }

    return {name: safeName, dataURI: off.toDataURL('image/jpeg', 1.0)};
  }

  function buildSvgString(name){
    const safeName = (name || 'joint').trim() || 'joint';
    if(!lastRender){ draw(); }
    const {bbox, segments, labels, joint} = lastRender;

    function esc(s){return (''+s).replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[c]));}

    let svg = [];
    svg.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${bbox.w}" height="${bbox.h}" viewBox="${bbox.x} ${bbox.y} ${bbox.w} ${bbox.h}" font-family="Times New Roman, Times, serif">`);
    svg.push(`<defs>
      <marker id="arrowGreenEnd" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
        <path d="M 10 5 L 0 1 L 0 9 z" fill="#2e7d32" />
      </marker>
      <marker id="arrowBlueEnd" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
        <path d="M 10 5 L 0 1 L 0 9 z" fill="#1e88e5" />
      </marker>
      <marker id="arrowRedEnd" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
        <path d="M 10 5 L 0 1 L 0 9 z" fill="#c62828" />
      </marker>
      <marker id="arrowGreenStart" viewBox="0 0 10 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 5 L 10 1 L 10 9 z" fill="#2e7d32" />
      </marker>
      <marker id="arrowBlueStart" viewBox="0 0 10 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 5 L 10 1 L 10 9 z" fill="#1e88e5" />
      </marker>
      <marker id="arrowRedStart" viewBox="0 0 10 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 5 L 10 1 L 10 9 z" fill="#c62828" />
      </marker>
    </defs>`);

    function markerId(color, headAtEnd){
      if(color==='#2e7d32') return headAtEnd?'arrowGreenEnd':'arrowGreenStart';
      if(color==='#1e88e5') return headAtEnd?'arrowBlueEnd':'arrowBlueStart';
      if(color==='#c62828') return headAtEnd?'arrowRedEnd':'arrowRedStart';
      return null;
    }

    for(const s of segments){
      const dashed = s.dashed;
      const mk = markerId(s.color, s.headAtEnd);
      svg.push(`<path d="M ${s.x1} ${s.y1} L ${s.x2} ${s.y2}" fill="none" stroke="${esc(s.color)}" stroke-width="3" stroke-linecap="round" ${dashed?'stroke-dasharray="6 6"':''} ${mk? (s.headAtEnd?`marker-end="url(#${mk})"`:`marker-start="url(#${mk})"`) : ''} />`);
    }

    svg.push(`<circle cx="${joint.x}" cy="${joint.y}" r="4" fill="#000"/>`);

    for(const p of labels){
      const deg = -(p.rot||0) * 180/Math.PI;
      const fontSize = /(\d+)px/.exec(p.font||'16px')?.[1] || 16;
      if(p.halo){
        svg.push(`<text x="${p.x}" y="${p.y}" font-size="${fontSize}" text-anchor="middle" dominant-baseline="middle" fill="none" stroke="#ffffff" stroke-width="4" stroke-linejoin="round" stroke-linecap="round" transform="rotate(${deg} ${p.x} ${p.y})">${esc(p.text)}</text>`);
      }
      svg.push(`<text x="${p.x}" y="${p.y}" font-size="${fontSize}" text-anchor="middle" dominant-baseline="middle" fill="${esc(p.color||'#000')}" fill-opacity="${p.alpha??1}" transform="rotate(${deg} ${p.x} ${p.y})">${esc(p.text)}</text>`);
    }

    svg.push(`</svg>`);
    return {name: safeName, svg: svg.join('')};
  }

  exportJpegBtn.addEventListener('click', () => {
    const {name, dataURI} = renderJpegDataURI(jointInput.value||'joint');
    downloadDataURI(`${name}.jpg`, dataURI);
  });

  exportSvgBtn.addEventListener('click', () => {
    const {name, svg} = buildSvgString(jointInput.value||'joint');
    const blob = new Blob([svg], {type:'image/svg+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name}.svg`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  });

  function dataUriToBytes(uri){
    const base64 = (uri.split(',')[1] || '').trim();
    const bin = atob(base64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return bytes;
  }

  const utf8 = new TextEncoder();
  function textToBytes(str){
    return utf8.encode(str);
  }

  const CRC32_TABLE = (() => {
    let c; const table = new Uint32Array(256);
    for(let n=0;n<256;n++){
      c = n;
      for(let k=0;k<8;k++) c = c & 1 ? 0xEDB88320 ^ (c>>>1) : c>>>1;
      table[n] = c >>> 0;
    }
    return table;
  })();

  function crc32(bytes){
    let crc = 0 ^ (-1);
    for(let i=0;i<bytes.length;i++){
      crc = (crc >>> 8) ^ CRC32_TABLE[(crc ^ bytes[i]) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
  }

  function dosDateTime(date=new Date()){
    const time = (date.getHours() << 11) | (date.getMinutes() << 5) | (date.getSeconds() >> 1);
    const dosDate = ((date.getFullYear() - 1980) << 9) | ((date.getMonth() + 1) << 5) | date.getDate();
    return {time, date: dosDate};
  }

  function buildZip(files){
    const parts = [];
    const central = [];
    let offset = 0;
    const records = [];

    for(const f of files){
      const nameBytes = textToBytes(f.name);
      const dataBytes = f.bytes instanceof Uint8Array ? f.bytes : textToBytes(String(f.bytes||''));
      const crc = crc32(dataBytes);
      const {time, date} = dosDateTime();
      const local = new Uint8Array(30 + nameBytes.length + dataBytes.length);
      const view = new DataView(local.buffer);
      view.setUint32(0, 0x04034b50, true);
      view.setUint16(4, 20, true);
      view.setUint16(6, 0, true);
      view.setUint16(8, 0, true); // store (no compression)
      view.setUint16(10, time, true);
      view.setUint16(12, date, true);
      view.setUint32(14, crc, true);
      view.setUint32(18, dataBytes.length, true);
      view.setUint32(22, dataBytes.length, true);
      view.setUint16(26, nameBytes.length, true);
      view.setUint16(28, 0, true);
      local.set(nameBytes, 30);
      local.set(dataBytes, 30 + nameBytes.length);
      parts.push(local);
      records.push({nameBytes, crc, size:dataBytes.length, offset, time, date});
      offset += local.length;
    }

    let centralSize = 0;
    for(const r of records){
      const cd = new Uint8Array(46 + r.nameBytes.length);
      const view = new DataView(cd.buffer);
      view.setUint32(0, 0x02014b50, true);
      view.setUint16(4, 0x14, true);
      view.setUint16(6, 20, true);
      view.setUint16(8, 0, true);
      view.setUint16(10, 0, true);
      view.setUint16(12, r.time, true);
      view.setUint16(14, r.date, true);
      view.setUint32(16, r.crc, true);
      view.setUint32(20, r.size, true);
      view.setUint32(24, r.size, true);
      view.setUint16(28, r.nameBytes.length, true);
      view.setUint16(30, 0, true);
      view.setUint16(32, 0, true);
      view.setUint16(34, 0, true);
      view.setUint16(36, 0, true);
      view.setUint32(38, 0, true);
      view.setUint32(42, r.offset, true);
      cd.set(r.nameBytes, 46);
      central.push(cd);
      centralSize += cd.length;
    }

    const end = new Uint8Array(22);
    const endView = new DataView(end.buffer);
    endView.setUint32(0, 0x06054b50, true);
    endView.setUint16(4, records.length, true);
    endView.setUint16(6, records.length, true);
    endView.setUint32(8, centralSize, true);
    endView.setUint32(12, offset, true);
    endView.setUint16(16, 0, true);
    endView.setUint16(18, 0, true);
    endView.setUint16(20, 0, true);

    return new Blob([...parts, ...central, end], {type:'application/zip'});
  }

  function downloadBlob(name, blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function exportAllAsZip(){
    saveCurrentJoint();
    const original = currentJoint;
    if(!truss.size){ truss.set(currentJoint, getMembers()); }
    const files = [];
    for(const [name] of truss){
      switchJoint(name);
      const jpeg = renderJpegDataURI(name);
      const svg = buildSvgString(name);
      files.push({name: `${jpeg.name}.jpg`, bytes: dataUriToBytes(jpeg.dataURI)});
      files.push({name: `${svg.name}.svg`, bytes: textToBytes(svg.svg)});
    }
    switchJoint(original);
    const zipBlob = buildZip(files);
    downloadBlob('truss-joints.zip', zipBlob);
  }

  clearBtn.addEventListener('click', () => {
    loadMembers([]);
    truss.set(currentJoint, []);
    draw();
  });

  addMemberBtn.addEventListener('click', () => makeMemberRow({}));

  jointInput.addEventListener('input', () => {
    const clean = sanitizeJointName(jointInput.value || currentJoint);
    jointInput.value = clean;
    if(clean !== currentJoint){
      const members = getMembers();
      truss.delete(currentJoint);
      currentJoint = clean;
      truss.set(currentJoint, members);
      updateJointTabs();
    }
    draw();
  });

  addJointBtn.addEventListener('click', () => addJoint(`J${truss.size+1}`));

  applyStructureBtn.addEventListener('click', () => {
    const parsed = parseStructure(structureText.value);
    applyStructure(parsed);
  });

  importFileBtn.addEventListener('click', () => importFileInput.click());
  importFileInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if(!file) return;
    const text = await file.text();
    const parsed = parseStructure(text);
    applyStructure(parsed);
    importFileInput.value = '';
  });

  exportZipBtn.addEventListener('click', exportAllAsZip);

  // Initial state
  resetToSingleJoint();
  makeMemberRow({ name:'AB', dir: 45 });
  truss.set(currentJoint, getMembers());
  updateJointTabs();
  fitCanvas();
  draw();
})();
</script>
</body>
</html>
