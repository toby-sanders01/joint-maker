<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="Single-page truss joint designer with refined Tailwind styling and export-ready outputs." />
<meta name="theme-color" content="#4f46e5" />
<title>Truss Joint Diagram Generator</title>
<script src="https://cdn.tailwindcss.com"></script>
<script>
  tailwind.config = {
    theme: {
      extend: {
        colors: {
          brand: {
            50: '#eef2ff',
            100: '#e0e7ff',
            500: '#4f46e5',
            600: '#4338ca',
            700: '#3730a3',
          }
        },
        fontFamily: {
          display: ['Inter', 'system-ui', 'sans-serif'],
        },
      }
    }
  }
</script>
<style>
  :root {
    --green: #10b981;
    --blue: #2563eb;
    --red: #ef4444;
  }
  body{font-family: "Inter", system-ui, -apple-system, sans-serif;}
  canvas{width:100%; height:auto;}
</style>
</head>

<body class="bg-gradient-to-br from-slate-50 via-white to-indigo-50 text-slate-900 min-h-screen">
  <header class="sticky top-0 z-10 border-b border-white/60 bg-white/80 backdrop-blur">
    <div class="mx-auto flex max-w-6xl flex-wrap items-center justify-between gap-4 px-6 py-4">
      <div class="flex flex-col gap-1">
        <p class="text-xs uppercase tracking-[0.2em] text-slate-500">Bridge Toolkit</p>
        <div class="flex items-center gap-3">
          <h1 class="text-2xl font-bold tracking-tight text-slate-900">Truss Joint Designer</h1>
          <span class="rounded-full border border-brand-100 bg-brand-50 px-3 py-1 text-xs font-semibold text-brand-700">Ready for Vercel</span>
        </div>
        <p class="text-sm text-slate-600">Single-page export tool for crisp, publication-ready joint diagrams.</p>
      </div>
      <div class="flex flex-wrap gap-2">
        <button id="exportJpegBtn" class="rounded-xl bg-brand-600 px-4 py-2 text-sm font-semibold text-white shadow-lg shadow-brand-600/30 ring-1 ring-brand-500 transition hover:-translate-y-0.5 hover:bg-brand-500">Export JPEGs</button>
        <button id="exportSvgBtn" class="rounded-xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5">Export SVG</button>
        <button id="exportZipBtn" class="rounded-xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5">Export ZIP</button>
        <button id="clearBtn" class="rounded-xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5">Reset</button>
      </div>
    </div>
  </header>

  <main class="mx-auto grid w-full max-w-6xl flex-1 grid-cols-1 gap-6 px-6 py-8 lg:grid-cols-[minmax(640px,1fr)_minmax(420px,0.8fr)]">
    <section class="rounded-3xl border border-white/80 bg-white/90 shadow-2xl shadow-slate-200/60 ring-1 ring-slate-100 backdrop-blur">
      <div class="flex flex-col gap-8 p-8">
        <div class="flex flex-col gap-3">
          <div class="flex items-center justify-between gap-4">
            <div>
              <p class="text-xs font-semibold uppercase tracking-[0.24em] text-slate-500">Joint</p>
              <h2 class="text-lg font-semibold text-slate-900">Identity & switching</h2>
            </div>
            <div class="flex flex-wrap items-center gap-2">
              <div id="jointTabs" class="flex flex-wrap gap-2"></div>
              <button id="addJointBtn" class="rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5" title="Add another joint to this truss">+ Joint</button>
            </div>
          </div>
          <div class="grid gap-3 md:grid-cols-2">
            <label class="flex flex-col gap-2 rounded-2xl border border-slate-200 bg-slate-50/70 p-4 shadow-inner shadow-slate-100">
              <span class="text-sm font-semibold text-slate-800">Joint name</span>
              <input id="jointName" type="text" placeholder="A" maxlength="6" class="w-full rounded-xl border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-sm focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200" />
              <span class="text-xs text-slate-500">Auto-uppercased and synced across exports.</span>
            </label>
            <div class="rounded-2xl border border-slate-200 bg-gradient-to-br from-slate-50 to-white p-4 shadow-sm">
              <div class="flex items-center gap-2 text-sm font-semibold text-slate-800">
                <span class="inline-flex h-8 w-8 items-center justify-center rounded-full bg-brand-50 text-brand-600">★</span>
                Single member focus
              </div>
              <p class="mt-2 text-sm text-slate-600">Streamlined for one precise member per joint—no clutter, no duplicate rows.</p>
            </div>
          </div>
        </div>

        <div class="rounded-2xl border border-slate-200 bg-slate-50/70 p-5 shadow-inner shadow-slate-100">
          <div class="flex items-center justify-between gap-2">
            <div>
              <p class="text-xs font-semibold uppercase tracking-[0.24em] text-slate-500">Member</p>
              <h3 class="text-lg font-semibold text-slate-900">Direction & loading</h3>
              <p class="text-sm text-slate-600">Complete a single member entry; the diagram updates instantly.</p>
            </div>
            <div class="text-xs text-slate-500">Tension → green · Compression → blue · Reaction → red</div>
          </div>

          <div class="mt-4 grid grid-cols-1 gap-4 lg:grid-cols-[180px_1fr_1fr_160px] lg:items-start">
            <label class="flex flex-col gap-2">
              <span class="text-sm font-semibold text-slate-800">Member name</span>
              <input id="memberName" type="text" placeholder="AB" class="w-full rounded-xl border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-sm focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200" />
            </label>

            <div class="flex flex-col gap-2">
              <div class="flex items-center justify-between text-sm font-semibold text-slate-800">
                <span>Direction (°)</span>
                <span class="text-xs font-medium text-slate-500">Quick picks</span>
              </div>
              <div class="grid grid-cols-2 gap-2 rounded-2xl border border-slate-200 bg-white p-3 shadow-sm md:grid-cols-4 lg:grid-cols-4">
                <input id="memberDir" type="number" step="0.1" min="0" max="360" class="col-span-2 rounded-lg border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-inner shadow-slate-100 focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200 md:col-span-1" placeholder="0 → right" />
                <div class="grid grid-cols-4 gap-1 col-span-2 md:col-span-3">
                  <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="0" title="Right">→</button>
                  <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="45" title="NE">↗</button>
                  <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="90" title="Up">↑</button>
                  <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="135" title="NW">↖</button>
                  <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="180" title="Left">←</button>
                  <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="225" title="SW">↙</button>
                  <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="270" title="Down">↓</button>
                  <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="315" title="SE">↘</button>
                </div>
              </div>
            </div>

            <label class="flex flex-col gap-2">
              <span class="text-sm font-semibold text-slate-800">Sense / type</span>
              <select id="memberSense" class="w-full rounded-xl border border-slate-200 px-3 py-2 text-sm font-semibold text-slate-900 shadow-inner shadow-slate-100 focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200">
                <option value="">— direction only —</option>
                <option value="Tension">Tension (green)</option>
                <option value="Compression">Compression (blue)</option>
                <option value="Reaction">Reaction (red)</option>
              </select>
              <span class="text-xs text-slate-500">Arrows flip automatically for compression and reaction.</span>
            </label>

            <label class="flex flex-col gap-2">
              <span class="text-sm font-semibold text-slate-800">Magnitude (kN)</span>
              <input id="memberMag" type="number" step="0.01" class="w-full rounded-xl border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-inner shadow-slate-100 focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200" placeholder="e.g., 64.94" />
              <span class="text-xs text-slate-500">Shown over the member line when provided.</span>
            </label>
          </div>
        </div>

        <div class="rounded-2xl border border-dashed border-slate-200 bg-slate-50/80 p-5 shadow-sm">
          <div class="flex flex-col gap-3">
            <div class="flex items-center gap-3">
              <span class="inline-flex h-10 w-10 items-center justify-center rounded-xl bg-brand-50 text-brand-600">⇪</span>
              <div>
                <p class="text-sm font-semibold text-slate-800">Optional batch import</p>
                <p class="text-sm text-slate-600">Paste or upload a structure file—only the first member per joint will be applied.</p>
              </div>
            </div>
            <textarea id="structureText" class="w-full min-h-[120px] rounded-xl border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-inner shadow-slate-100 focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200" placeholder="A,AB,0,Tension,50
A,AC,45,Compression,30
B,BA,180,Reaction,18"></textarea>
            <div class="flex flex-wrap items-center gap-2">
              <button id="applyStructureBtn" class="rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5">Apply structure</button>
              <button id="importFileBtn" class="rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5" title="Import structure from JSON/CSV">Import file</button>
              <input type="file" id="importFile" accept=".json,.csv,.txt" class="hidden" />
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="relative rounded-3xl border border-white/80 bg-gradient-to-b from-white to-slate-50 p-5 shadow-2xl shadow-slate-200/60 ring-1 ring-slate-100">
      <div class="flex items-center justify-between px-1 pb-3">
        <div>
          <p class="text-xs font-semibold uppercase tracking-[0.24em] text-slate-500">Preview</p>
          <h2 class="text-lg font-semibold text-slate-900">Live canvas</h2>
        </div>
        <div class="flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1 text-xs text-slate-600 shadow-sm">
          <span class="inline-flex items-center gap-2"><span class="h-1 w-5 rounded-full bg-emerald-600"></span> Tension</span>
          <span class="inline-flex items-center gap-2"><span class="h-1 w-5 rounded-full bg-blue-600"></span> Compression</span>
          <span class="inline-flex items-center gap-2"><span class="h-1 w-5 rounded-full bg-red-600"></span> Reaction</span>
          <span class="inline-flex items-center gap-2"><span class="h-1 w-5 rounded-full bg-slate-500"></span> Direction only</span>
        </div>
      </div>
      <canvas id="cnv" width="1400" height="950" aria-label="diagram canvas" class="overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-inner shadow-slate-100"></canvas>
    </section>
  </main>

<script>
(() => {
  const $ = (sel, el=document) => el.querySelector(sel);
  const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

  const cnv = $('#cnv');
  const ctx = cnv.getContext('2d');
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  function fitCanvas() {
    const w = cnv.clientWidth;
    const h = cnv.clientHeight;
    cnv.width = Math.round(w * DPR);
    cnv.height = Math.round(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    draw();
  }
  new ResizeObserver(fitCanvas).observe(cnv);

  const memberNameInput = $('#memberName');
  const memberDirInput = $('#memberDir');
  const memberSenseInput = $('#memberSense');
  const memberMagInput = $('#memberMag');
  const dirButtons = $$('.dirbtn');
  const exportJpegBtn = $('#exportJpegBtn');
  const exportSvgBtn = $('#exportSvgBtn');
  const exportZipBtn = $('#exportZipBtn');
  const clearBtn = $('#clearBtn');
  const jointInput = $('#jointName');
  const jointTabs = $('#jointTabs');
  const addJointBtn = $('#addJointBtn');
  const structureText = $('#structureText');
  const applyStructureBtn = $('#applyStructureBtn');
  const importFileBtn = $('#importFileBtn');
  const importFileInput = $('#importFile');

  const truss = new Map();
  let currentJoint = 'A';
  let lastRender = null; // geometry and bbox for exports

  function updateJointTabs(){
    jointTabs.innerHTML = '';
    for(const [name] of truss){
      const btn = document.createElement('button');
      btn.className = (name === currentJoint)
        ? 'rounded-lg border border-brand-200 bg-brand-50 px-3 py-2 text-sm font-semibold text-brand-700 shadow-sm ring-1 ring-brand-200 transition'
        : 'rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5';
      btn.textContent = name;
      btn.title = `Switch to joint ${name}`;
      btn.addEventListener('click', () => switchJoint(name));
      jointTabs.appendChild(btn);
    }
  }

  function saveCurrentJoint(){
    const members = getMembers();
    truss.set(currentJoint, members);
  }

  function loadMembers(list){
    const m = (list && list[0]) || {};
    memberNameInput.value = m.name || '';
    memberDirInput.value = (m.dir ?? '') === null ? '' : (m.dir ?? '');
    memberSenseInput.value = m.sense || '';
    const magDisplay = m.magStr !== undefined ? m.magStr : (m.mag ?? '');
    memberMagInput.value = magDisplay === null ? '' : (magDisplay ?? '');
  }

  function switchJoint(name){
    const target = sanitizeJointName(name);
    saveCurrentJoint();
    currentJoint = target;
    jointInput.value = target;
    loadMembers(truss.get(target));
    updateJointTabs();
    draw();
  }

  function addJoint(name=''){ 
    const clean = sanitizeJointName(name || `J${truss.size+1}`);
    if(!truss.has(clean)){
      truss.set(clean, []);
    }
    switchJoint(clean);
  }

  function resetToSingleJoint(){
    truss.clear();
    currentJoint = 'A';
    truss.set(currentJoint, []);
    jointInput.value = currentJoint;
    loadMembers([{name:'AB', dir:45}]);
    saveCurrentJoint();
    updateJointTabs();
    draw();
  }

  function sanitizeJointName(name){
    const val = (name || '').trim().toUpperCase().slice(0, 6) || 'A';
    return val;
  }

  function getMembers(){
    const joint = sanitizeJointName(jointInput.value || currentJoint);
    const name = memberNameInput.value.trim().toUpperCase();
    const dirVal = memberDirInput.value;
    const dir = dirVal === '' ? null : parseFloat(dirVal);
    const sense = memberSenseInput.value;
    const magStr = memberMagInput.value.trim();
    const mag = magStr === '' ? null : parseFloat(magStr);
    return [{ name, dir: (dir!==null && Number.isFinite(dir)) ? dir : null, sense, mag: (mag!==null && Number.isFinite(mag)) ? mag : null, magStr, joint }];
  }

  function parseStructure(text){
    const res = new Map();
    const raw = (text || '').trim();
    if(!raw) return res;
    try{
      const data = JSON.parse(raw);
      if(Array.isArray(data)){
        for(const entry of data){
          const j = sanitizeJointName(entry.joint || entry.name || '');
          if(!j) continue;
          const members = Array.isArray(entry.members) ? entry.members.map(m => ({
            name:(m.name||'').toString().toUpperCase(),
            dir: m.dir===null||m.dir===undefined?null:Number(m.dir),
            sense: m.sense||m.type||'',
            mag: m.mag===null||m.mag===undefined?null:Number(m.mag),
            magStr: m.mag===null||m.mag===undefined? '': String(m.mag)
          })) : [];
          res.set(j, members);
        }
      }
      if(res.size) return res;
    }catch(e){ /* fall back to line parser */ }

    const lines = raw.split(/\r?\n/);
    for(const line of lines){
      const clean = line.trim();
      if(!clean || clean.startsWith('#')) continue;
      const parts = clean.split(/[,;\t]/).map(p=>p.trim());
      if(parts.length < 2) continue;
      const [jRaw, nameRaw, dirRaw, senseRaw, magRaw] = parts;
      const joint = sanitizeJointName(jRaw);
      if(!joint) continue;
      const members = res.get(joint) || [];
      const dir = dirRaw === '' || dirRaw === undefined ? null : Number(dirRaw);
      const mag = magRaw === '' || magRaw === undefined ? null : Number(magRaw);
      members.push({
        name:(nameRaw||'').toUpperCase(),
        dir: Number.isFinite(dir)?dir:null,
        sense: senseRaw || '',
        mag: Number.isFinite(mag)?mag:null,
        magStr: (magRaw??'').toString(),
        joint
      });
      res.set(joint, members);
    }
    return res;
  }

  function applyStructure(res){
    if(!res || !res.size) return;
    saveCurrentJoint();
    truss.clear();
    for(const [j, members] of res){
      const first = Array.isArray(members) && members.length ? [members[0]] : [];
      truss.set(sanitizeJointName(j), first);
    }
    const first = res.keys().next().value || 'A';
    switchJoint(first);
  }

  function clearCanvas(){
    const w = cnv.width / DPR;
    const h = cnv.height / DPR;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,cnv.width,cnv.height);
    ctx.restore();
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,w,h);
  }

  // geometry helpers
  function expandBBox(b, x, y){ b.minX = Math.min(b.minX, x); b.minY = Math.min(b.minY, y); b.maxX = Math.max(b.maxX, x); b.maxY = Math.max(b.maxY, y); }
  function expandRect(b, cx, cy, w, h, rot){
    const hw = w/2, hh = h/2;
    const c = Math.cos(-rot||0), s = Math.sin(-rot||0);
    const pts = [[-hw,-hh],[hw,-hh],[hw,hh],[-hw,hh]];
    for(const [dx,dy] of pts){
      const x = cx + c*dx - s*dy;
      const y = cy + s*dx + c*dy;
      expandBBox(b, x, y);
    }
  }

  function drawArrow(x1,y1,x2,y2, color, headAtEnd=true, b=null, c=ctx){
    // line
    c.strokeStyle = color;
    c.lineWidth = 3;
    c.lineCap = 'round';
    c.beginPath();
    c.moveTo(x1,y1);
    c.lineTo(x2,y2);
    c.stroke();
    if(b){ expandBBox(b, x1, y1); expandBBox(b, x2, y2); }
    // arrow head (larger)
    const ang = Math.atan2(y2 - y1, x2 - x1);
    const size = 14;
    const hx = headAtEnd ? x2 : x1;
    const hy = headAtEnd ? y2 : y1;
    const theta = headAtEnd ? ang : ang + Math.PI;

    c.beginPath();
    c.moveTo(hx, hy);
    const p1 = [hx - size * Math.cos(theta - Math.PI/7), hy - size * Math.sin(theta - Math.PI/7)];
    const p2 = [hx - size * Math.cos(theta + Math.PI/7), hy - size * Math.sin(theta + Math.PI/7)];
    c.lineTo(...p1);
    c.lineTo(...p2);
    c.closePath();
    c.fillStyle = color;
    c.fill();
    if(b){ expandBBox(b, hx, hy); expandBBox(b, p1[0], p1[1]); expandBBox(b, p2[0], p2[1]); }
  }

  function distancePointToSegment(px,py, x1,y1,x2,y2){
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A*C + B*D;
    const len_sq = C*C + D*D;
    let param = -1;
    if (len_sq !== 0) param = dot / len_sq;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function measure(text, font){
    ctx.save();
    ctx.font = font;
    const w = ctx.measureText(text).width;
    ctx.restore();
    return {w, h: 16};
  }

  function projAlong(px,py, x1,y1, ux,uy){
    return ( (px - x1) * ux + (py - y1) * uy );
  }

  function draw(){
    clearCanvas();
    const w = cnv.width / DPR;
    const h = cnv.height / DPR;
    const cx = Math.round(w*0.62);
    const cy = Math.round(h*0.50);

    const joint = sanitizeJointName(jointInput.value || currentJoint);
    jointInput.value = joint;
    const L = Math.min(w,h) * 0.28;

    const style = getComputedStyle(document.documentElement);
    const colors = {
      'Tension': style.getPropertyValue('--green').trim(),
      'Compression': style.getPropertyValue('--blue').trim(),
      'Reaction': style.getPropertyValue('--red').trim(),
      'Guide': '#8a8f9e'
    };

    const members = getMembers();

    const segments = []; // for exports
    const labels = [];   // for exports
    const bbox = {minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity};

    const END_MARGIN = 24; // min distance of magnitude text from both ends

    function rectHitsPlaced(x,y,tw,th){
      const r = Math.hypot(tw, th) * 0.48;
      for(const p of labels){
        const rp = Math.hypot(p.tw, p.th) * 0.48;
        const d = Math.hypot(x - p.x, y - p.y);
        if(d < r + rp + 2) return true;
      }
      return false;
    }
    function candidateHitsSegments(x,y,tw,th, angle, along, allowOverlap){
      if(allowOverlap) return false; // allow over-the-line for magnitudes
      for(const s of segments){
        const d = distancePointToSegment(x, y, s.x1, s.y1, s.x2, s.y2);
        const threshold = along ? Math.max(th/2 + 8, 14) : Math.max(Math.hypot(tw,th)*0.50, 9);
        if(d < threshold) return true;
      }
      return false;
    }
    function tooCloseToEnds(x,y,tw,th, seg){
      const half = tw/2;
      const pr = projAlong(x,y, seg.x1, seg.y1, seg.ux, seg.uy);
      return (pr - half) < END_MARGIN || (pr + half) > (seg.L - END_MARGIN);
    }

    function putNearPoint(text, baseX, baseY, opts={}){
      const font = `${opts.size||16}px "Times New Roman", Times, serif`;
      const m = measure(text, font);
      const tw = m.w, th = m.h;
      const radii = opts.radii || [0,2,4,6,8,12,16];
      const dirs = opts.dirs || [0,45,90,135,180,225,270,315];
      for(const r of radii){
        for(const d of dirs){
          const a = d*Math.PI/180;
          const x = baseX + r*Math.cos(a);
          const y = baseY - r*Math.sin(a);
          if(!candidateHitsSegments(x,y,tw,th, 0, false, false) && !rectHitsPlaced(x,y,tw,th)){
            const obj = {x,y,tw,th,rot:0, color:opts.color||'#000', font, text, alpha: 1, halo:false};
            labels.push(obj);
            expandRect(bbox, obj.x, obj.y, tw+4, th+4, obj.rot);
            return obj;
          }
        }
      }
      const obj = {x:baseX,y:baseY,tw,th,rot:0, color:opts.color||'#000', font, text, alpha: 1, halo:false};
      labels.push(obj);
      expandRect(bbox, obj.x, obj.y, tw+4, th+4, obj.rot);
      return obj;
    }

    function putLabel(text, baseX, baseY, opts={angle:0, color:'#000', size:16, alignAlong:false, nearPoint:false, seg:null, minNormal:null, halo:false, alpha:1, overLine:false}){
      if(opts.nearPoint) return putNearPoint(text, baseX, baseY, opts);
      const font = `${opts.size||16}px "Times New Roman", Times, serif`;
      const m = measure(text, font);
      const tw = m.w, th = m.h;

      const tries = [];
      if(opts.alignAlong){
        const ang = opts.angle || 0;
        const ux = Math.cos(ang), uy = Math.sin(ang);
        const nx = -Math.sin(ang), ny = Math.cos(ang);
        const minP = Math.max(opts.minNormal ?? 0, 0); // allow being on the line
        for(let p=minP; p<=minP+8; p+=2){       // stay right on or near the line
          for(let s=0; s<=36; s+=6){            // small slides along
            tries.push([baseX + ux*s + nx*p, baseY - uy*s + ny*p, ang, true]);
            if(s>0) tries.push([baseX - ux*s + nx*p, baseY + uy*s + ny*p, ang, true]);
          }
        }
      }else{
        const radii = [0,2,4,6,8,12];
        const dirs = [0,45,90,135,180,225,270,315];
        for(const r of radii){
          for(const d of dirs){
            const a = d*Math.PI/180;
            tries.push([baseX + r*Math.cos(a), baseY - r*Math.sin(a), 0, false]);
          }
        }
      }
      for(const [x,y,rot,along] of tries){
        if(opts.seg && along && tooCloseToEnds(x,y,tw,th, opts.seg)) continue;
        if(!candidateHitsSegments(x,y,tw,th, rot, along, opts.overLine) && !rectHitsPlaced(x,y,tw,th)){
          const obj = {x,y,tw,th,rot, color:opts.color, font, text, halo: !!opts.halo, alpha: opts.alpha ?? 1};
          labels.push(obj);
          const haloPad = obj.halo ? 4 : 0;
          expandRect(bbox, obj.x, obj.y, tw+haloPad, th+haloPad, obj.rot);
          return obj;
        }
      }
      const obj = {x:baseX,y:baseY,tw,th,rot:opts.angle||0, color:opts.color, font, text, halo: !!opts.halo, alpha: opts.alpha ?? 1};
      labels.push(obj);
      const haloPad = obj.halo ? 4 : 0;
      expandRect(bbox, obj.x, obj.y, tw+haloPad, th+haloPad, obj.rot);
      return obj;
    }

    // Draw members and labels
    const JOINT = {x: cx, y: cy};
    for(const m of members){
      if(m.dir === null) continue;
      const rad = (m.dir % 360) * Math.PI/180;
      const x2 = cx + L*Math.cos(rad);
      const y2 = cy - L*Math.sin(rad);
      const ux = Math.cos(rad), uy = -Math.sin(rad); // canvas y inverted
      const nx = -Math.sin(rad), ny = Math.cos(rad);

      const seg = {x1:cx, y1:cy, x2, y2, ux, uy, L, color:colors[m.sense] || '#8a8f9e', dashed: !m.sense, headAtEnd: !(m.sense === 'Compression' || m.sense === 'Reaction')};

      // store for export
      segments.push(seg);

      // draw
      if(!m.sense){
        ctx.strokeStyle = 'rgba(120,120,130,.5)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6,6]);
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.lineTo(x2,y2);
        ctx.stroke();
        ctx.setLineDash([]);
        expandBBox(bbox, cx, cy); expandBBox(bbox, x2, y2);
      } else {
        drawArrow(cx, cy, x2, y2, seg.color, seg.headAtEnd, bbox);
      }

      // Far-end node letter
      const name = (m.name||'').replace(/[^A-Z]/g,'').toUpperCase();
      if(name){
        const letters = name.split('');
        const other = letters.find(ch => ch !== m.joint) || name;
        const tipx = cx + L*ux, tipy = cy + L*uy;
        const fx = tipx + nx*10;
        const fy = tipy + ny*10;
        putLabel(other, fx, fy, {size:16, color:'#000', nearPoint:true});
      }

      // Magnitude label (over the line)
      if(m.magStr && m.magStr.length && m.sense){
        const frac = 0.62;
        const base = { x: cx + (L*frac)*ux, y: cy + (L*frac)*uy };
        const obj = putLabel(`${m.magStr} kN`, base.x, base.y, {
          angle: rad,
          color: colors[m.sense],
          size: 16,
          alignAlong: true,
          seg,
          overLine: true,
          halo: true,
          alpha: 0.92
        });
        obj.rot = (Math.cos(rad) < 0) ? (rad + Math.PI) : rad;
      }
    }

    // Joint node + label
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI*2);
    ctx.fill();
    expandBBox(bbox, cx-4, cy-4); expandBBox(bbox, cx+4, cy+4);

    putNearPoint((joint||'A'), cx, cy, {
      size:16, color:'#000',
      radii:[8,10,12,14,16,18,20],
      dirs:[0,45,315,90,270,135,225,180]
    });

    // Render labels on top
    for(const p of labels){
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(-(p.rot || 0));
      ctx.font = p.font || '16px "Times New Roman", Times, serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if(p.halo){
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#ffffff';
        ctx.strokeText(p.text, 0, 0);
      }
      ctx.globalAlpha = p.alpha ?? 1;
      ctx.fillStyle = p.color || '#000';
      ctx.fillText(p.text, 0, 0);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Save render info for exports
    const PAD = 12;
    const minX = Math.max(0, Math.floor(bbox.minX - PAD));
    const minY = Math.max(0, Math.floor(bbox.minY - PAD));
    const maxX = Math.min(w, Math.ceil(bbox.maxX + PAD));
    const maxY = Math.min(h, Math.ceil(bbox.maxY + PAD));
    lastRender = {
      width: w, height: h, bbox:{x:minX,y:minY,w:Math.max(4,maxX-minX),h:Math.max(4,maxY-minY)},
      segments, labels, joint: JOINT, colors
    };
  }

  // ----- EXPORTS -----
  function downloadDataURI(name, dataURI){
    const link = document.createElement('a');
    link.download = name;
    link.href = dataURI;
    document.body.appendChild(link);
    link.click();
    link.remove();
  }

  function renderJpegDataURI(name){
    const safeName = (name || 'joint').trim() || 'joint';
    if(!lastRender){ draw(); }
    const SCALE = 4; // 4x size
    const {bbox, segments, labels, joint} = lastRender;

    const off = document.createElement('canvas');
    const PX = Math.max(1, Math.round(bbox.w * SCALE * DPR));
    const PY = Math.max(1, Math.round(bbox.h * SCALE * DPR));
    off.width = PX; off.height = PY;
    const c = off.getContext('2d');
    c.fillStyle = '#ffffff';
    c.fillRect(0,0,PX,PY);
    c.setTransform(DPR*SCALE, 0, 0, DPR*SCALE, -bbox.x*DPR*SCALE, -bbox.y*DPR*SCALE);

    c.lineCap = 'round';
    for(const s of segments){
      if(s.dashed){
        c.strokeStyle = 'rgba(120,120,130,.5)';
        c.lineWidth = 1.5;
        c.setLineDash([6,6]);
        c.beginPath();
        c.moveTo(s.x1,s.y1);
        c.lineTo(s.x2,s.y2);
        c.stroke();
        c.setLineDash([]);
      }else{
        drawArrow(s.x1,s.y1,s.x2,s.y2, s.color, s.headAtEnd, null, c);
      }
    }
    c.fillStyle = '#000';
    c.beginPath();
    c.arc(joint.x, joint.y, 4, 0, Math.PI*2);
    c.fill();

    for(const p of labels){
      c.save();
      c.translate(p.x, p.y);
      c.rotate(-(p.rot || 0));
      const fontSize = /(\d+)px/.exec(p.font||'16px')?.[1] || 16;
      c.font = `${fontSize}px "Times New Roman", Times, serif`;
      c.textAlign = 'center';
      c.textBaseline = 'middle';
      if(p.halo){
        c.lineWidth = 4;
        c.strokeStyle = '#ffffff';
        c.strokeText(p.text, 0, 0);
      }
      c.globalAlpha = p.alpha ?? 1;
      c.fillStyle = p.color || '#000';
      c.fillText(p.text, 0, 0);
      c.globalAlpha = 1;
      c.restore();
    }

    return {name: safeName, dataURI: off.toDataURL('image/jpeg', 1.0)};
  }

  function exportAllJpegs(){
    saveCurrentJoint();
    const original = currentJoint;
    if(!truss.size){ truss.set(currentJoint, getMembers()); }
    const renders = [];
    for(const [name] of truss){
      switchJoint(name);
      renders.push(renderJpegDataURI(name));
    }
    switchJoint(original);

    if(renders.length === 1){
      const single = renders[0];
      downloadDataURI(`${single.name}.jpg`, single.dataURI);
      return;
    }

    const files = renders.map(r => ({ name: `${r.name}.jpg`, bytes: dataUriToBytes(r.dataURI) }));
    const zipBlob = buildZip(files);
    downloadBlob('truss-joints-jpegs.zip', zipBlob);
  }

  function buildSvgString(name){
    const safeName = (name || 'joint').trim() || 'joint';
    if(!lastRender){ draw(); }
    const {bbox, segments, labels, joint} = lastRender;

    function esc(s){return (''+s).replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[c]));}

    let svg = [];
    svg.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${bbox.w}" height="${bbox.h}" viewBox="${bbox.x} ${bbox.y} ${bbox.w} ${bbox.h}" font-family="Times New Roman, Times, serif">`);
    svg.push(`<defs>
      <marker id="arrowGreenEnd" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
        <path d="M 10 5 L 0 1 L 0 9 z" fill="#2e7d32" />
      </marker>
      <marker id="arrowBlueEnd" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
        <path d="M 10 5 L 0 1 L 0 9 z" fill="#1e88e5" />
      </marker>
      <marker id="arrowRedEnd" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
        <path d="M 10 5 L 0 1 L 0 9 z" fill="#c62828" />
      </marker>
      <marker id="arrowGreenStart" viewBox="0 0 10 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 5 L 10 1 L 10 9 z" fill="#2e7d32" />
      </marker>
      <marker id="arrowBlueStart" viewBox="0 0 10 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 5 L 10 1 L 10 9 z" fill="#1e88e5" />
      </marker>
      <marker id="arrowRedStart" viewBox="0 0 10 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 5 L 10 1 L 10 9 z" fill="#c62828" />
      </marker>
    </defs>`);

    function markerId(color, headAtEnd){
      if(color==='#2e7d32') return headAtEnd?'arrowGreenEnd':'arrowGreenStart';
      if(color==='#1e88e5') return headAtEnd?'arrowBlueEnd':'arrowBlueStart';
      if(color==='#c62828') return headAtEnd?'arrowRedEnd':'arrowRedStart';
      return null;
    }

    for(const s of segments){
      const dashed = s.dashed;
      const mk = markerId(s.color, s.headAtEnd);
      svg.push(`<path d="M ${s.x1} ${s.y1} L ${s.x2} ${s.y2}" fill="none" stroke="${esc(s.color)}" stroke-width="3" stroke-linecap="round" ${dashed?'stroke-dasharray="6 6"':''} ${mk? (s.headAtEnd?`marker-end="url(#${mk})"`:`marker-start="url(#${mk})"`) : ''} />`);
    }

    svg.push(`<circle cx="${joint.x}" cy="${joint.y}" r="4" fill="#000"/>`);

    for(const p of labels){
      const deg = -(p.rot||0) * 180/Math.PI;
      const fontSize = /(\d+)px/.exec(p.font||'16px')?.[1] || 16;
      if(p.halo){
        svg.push(`<text x="${p.x}" y="${p.y}" font-size="${fontSize}" text-anchor="middle" dominant-baseline="middle" fill="none" stroke="#ffffff" stroke-width="4" stroke-linejoin="round" stroke-linecap="round" transform="rotate(${deg} ${p.x} ${p.y})">${esc(p.text)}</text>`);
      }
      svg.push(`<text x="${p.x}" y="${p.y}" font-size="${fontSize}" text-anchor="middle" dominant-baseline="middle" fill="${esc(p.color||'#000')}" fill-opacity="${p.alpha??1}" transform="rotate(${deg} ${p.x} ${p.y})">${esc(p.text)}</text>`);
    }

    svg.push(`</svg>`);
    return {name: safeName, svg: svg.join('')};
  }

  exportJpegBtn.addEventListener('click', exportAllJpegs);

  exportSvgBtn.addEventListener('click', () => {
    const {name, svg} = buildSvgString(jointInput.value||'joint');
    const blob = new Blob([svg], {type:'image/svg+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name}.svg`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  });

  function dataUriToBytes(uri){
    const base64 = (uri.split(',')[1] || '').trim();
    const bin = atob(base64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return bytes;
  }

  const utf8 = new TextEncoder();
  function textToBytes(str){
    return utf8.encode(str);
  }

  const CRC32_TABLE = (() => {
    let c; const table = new Uint32Array(256);
    for(let n=0;n<256;n++){
      c = n;
      for(let k=0;k<8;k++) c = c & 1 ? 0xEDB88320 ^ (c>>>1) : c>>>1;
      table[n] = c >>> 0;
    }
    return table;
  })();

  function crc32(bytes){
    let crc = 0 ^ (-1);
    for(let i=0;i<bytes.length;i++){
      crc = (crc >>> 8) ^ CRC32_TABLE[(crc ^ bytes[i]) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
  }

  function dosDateTime(date=new Date()){
    const time = (date.getHours() << 11) | (date.getMinutes() << 5) | (date.getSeconds() >> 1);
    const dosDate = ((date.getFullYear() - 1980) << 9) | ((date.getMonth() + 1) << 5) | date.getDate();
    return {time, date: dosDate};
  }

  function buildZip(files){
    const parts = [];
    const central = [];
    let offset = 0;
    const records = [];

    for(const f of files){
      const nameBytes = textToBytes(f.name);
      const dataBytes = f.bytes instanceof Uint8Array ? f.bytes : textToBytes(String(f.bytes||''));
      const crc = crc32(dataBytes);
      const {time, date} = dosDateTime();
      const local = new Uint8Array(30 + nameBytes.length + dataBytes.length);
      const view = new DataView(local.buffer);
      view.setUint32(0, 0x04034b50, true);
      view.setUint16(4, 20, true);
      view.setUint16(6, 0, true);
      view.setUint16(8, 0, true); // store (no compression)
      view.setUint16(10, time, true);
      view.setUint16(12, date, true);
      view.setUint32(14, crc, true);
      view.setUint32(18, dataBytes.length, true);
      view.setUint32(22, dataBytes.length, true);
      view.setUint16(26, nameBytes.length, true);
      view.setUint16(28, 0, true);
      local.set(nameBytes, 30);
      local.set(dataBytes, 30 + nameBytes.length);
      parts.push(local);
      records.push({nameBytes, crc, size:dataBytes.length, offset, time, date});
      offset += local.length;
    }

    let centralSize = 0;
    for(const r of records){
      const cd = new Uint8Array(46 + r.nameBytes.length);
      const view = new DataView(cd.buffer);
      view.setUint32(0, 0x02014b50, true);
      view.setUint16(4, 0x14, true);
      view.setUint16(6, 20, true);
      view.setUint16(8, 0, true);
      view.setUint16(10, 0, true);
      view.setUint16(12, r.time, true);
      view.setUint16(14, r.date, true);
      view.setUint32(16, r.crc, true);
      view.setUint32(20, r.size, true);
      view.setUint32(24, r.size, true);
      view.setUint16(28, r.nameBytes.length, true);
      view.setUint16(30, 0, true);
      view.setUint16(32, 0, true);
      view.setUint16(34, 0, true);
      view.setUint16(36, 0, true);
      view.setUint32(38, 0, true);
      view.setUint32(42, r.offset, true);
      cd.set(r.nameBytes, 46);
      central.push(cd);
      centralSize += cd.length;
    }

    const end = new Uint8Array(22);
    const endView = new DataView(end.buffer);
    endView.setUint32(0, 0x06054b50, true);
    endView.setUint16(4, records.length, true);
    endView.setUint16(6, records.length, true);
    endView.setUint32(8, centralSize, true);
    endView.setUint32(12, offset, true);
    endView.setUint16(16, 0, true);
    endView.setUint16(18, 0, true);
    endView.setUint16(20, 0, true);

    return new Blob([...parts, ...central, end], {type:'application/zip'});
  }

  function downloadBlob(name, blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function exportAllAsZip(){
    saveCurrentJoint();
    const original = currentJoint;
    if(!truss.size){ truss.set(currentJoint, getMembers()); }
    const files = [];
    for(const [name] of truss){
      switchJoint(name);
      const jpeg = renderJpegDataURI(name);
      const svg = buildSvgString(name);
      files.push({name: `${jpeg.name}.jpg`, bytes: dataUriToBytes(jpeg.dataURI)});
      files.push({name: `${svg.name}.svg`, bytes: textToBytes(svg.svg)});
    }
    switchJoint(original);
    const zipBlob = buildZip(files);
    downloadBlob('truss-joints.zip', zipBlob);
  }

  dirButtons.forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      memberDirInput.value = btn.dataset.deg;
      saveCurrentJoint();
      draw();
    });
  });

  [memberNameInput, memberDirInput, memberSenseInput, memberMagInput].forEach(el => {
    el.addEventListener('input', () => { saveCurrentJoint(); draw(); });
    el.addEventListener('change', () => { saveCurrentJoint(); draw(); });
  });

  clearBtn.addEventListener('click', () => {
    loadMembers([]);
    truss.set(currentJoint, []);
    draw();
  });

  jointInput.addEventListener('input', () => {
    const clean = sanitizeJointName(jointInput.value || currentJoint);
    jointInput.value = clean;
    if(clean !== currentJoint){
      const members = getMembers();
      truss.delete(currentJoint);
      currentJoint = clean;
      truss.set(currentJoint, members);
      updateJointTabs();
    }
    draw();
  });

  addJointBtn.addEventListener('click', () => addJoint(`J${truss.size+1}`));

  applyStructureBtn.addEventListener('click', () => {
    const parsed = parseStructure(structureText.value);
    applyStructure(parsed);
  });

  importFileBtn.addEventListener('click', () => importFileInput.click());
  importFileInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if(!file) return;
    const text = await file.text();
    const parsed = parseStructure(text);
    applyStructure(parsed);
    importFileInput.value = '';
  });

  exportZipBtn.addEventListener('click', exportAllAsZip);

  // Initial state
  resetToSingleJoint();
  updateJointTabs();
  fitCanvas();
  draw();
})();
</script>
</body>
</html>
