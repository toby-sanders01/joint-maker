><!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="Single-page truss joint designer with refined Tailwind styling and export-ready outputs." />
<meta name="theme-color" content="#4f46e5" />
<title>Truss Joint Diagram Generator</title>
<script src="https://cdn.tailwindcss.com"></script>
<script>
  tailwind.config = {
    theme: {
      extend: {
        colors: {
          brand: {
            50: '#eef2ff',
            100: '#e0e7ff',
            500: '#4f46e5',
            600: '#4338ca',
            700: '#3730a3',
          }
        },
        fontFamily: {
          display: ['Inter', 'system-ui', 'sans-serif'],
        },
      }
    }
  }
</script>
<style>
  :root {
    --green: #10b981;
    --blue: #2563eb;
    --red: #ef4444;
  }
  body{font-family: "Inter", system-ui, -apple-system, sans-serif;}
  canvas{width:100%; height:auto;}

  /* Make grid children able to shrink so columns don't expand to fit
     intrinsic-width children (prevents the Sense/select from escaping
     the rounded card at intermediate widths). */
  .member-row .grid > * { min-width: 0; }
  .member-row .member-name,
  .member-row .member-dir,
  .member-row .member-sense,
  .member-row .member-mag { min-width: 0; }
  .member-row input,
  .member-row select,
  .member-row textarea { min-width: 0; box-sizing: border-box; }

  /* Apply min-width/max-width/box-sizing to all descendants inside the
     member card so nested grids (the quick-pick buttons) can't force
     their parent's column to grow. Using !important here ensures
     these rules override Tailwind utility classes when necessary. */
  .member-row .grid,
  .member-row .grid * {
    min-width: 0 !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
  }

  /* Convert the inner arrow-button grid to a wrapping flex row so the
     arrow buttons wrap to the next line when space is tight instead of
     forcing the whole card wider. This only targets the small grid used
     for arrow buttons (it has the utility class `grid-cols-4`). */
  .member-row .grid.grid-cols-4,
  .member-row .grid > .grid.grid-cols-4 {
    display: flex !important;
    flex-wrap: wrap !important;
    gap: 0.25rem !important;
    align-items: center !important;
  }

  .member-row .dirbtn {
    flex: 0 0 auto !important;
  }

  /* Ensure controls don't exceed their cell */
  .member-row input,
  .member-row select,
  .member-row textarea,
  .member-row button { max-width: 100% !important; }

  /* At medium and larger widths, place Sense and Magnitude under the
     Direction column so they always sit beneath Direction rather than
     to its right. We target the grid children by their source order:
     1 = name, 2 = direction, 3 = sense, 4 = magnitude. */
  @media (min-width: 768px) {
    .member-row .grid {
      grid-template-columns: minmax(200px, 1fr) minmax(360px, 1.2fr);
      grid-auto-rows: auto;
      column-gap: 1rem;
      row-gap: 0.75rem;
    }
    .member-row .grid > :nth-child(1) { grid-column: 1; grid-row: 1; }
    .member-row .grid > :nth-child(2) { grid-column: 2; grid-row: 1; }
    .member-row .grid > :nth-child(3) { grid-column: 2; grid-row: 2; }
    .member-row .grid > :nth-child(4) { grid-column: 2; grid-row: 3; }
    .member-row .grid > :nth-child(1) label,
    .member-row .grid > :nth-child(3) label,
    .member-row .grid > :nth-child(4) label { display: block; }
  }
</style>
</head>

<body class="bg-gradient-to-br from-slate-50 via-white to-indigo-50 text-slate-900 min-h-screen">
  <header class="sticky top-0 z-10 border-b border-white/60 bg-white/80 backdrop-blur">
    <div class="mx-auto flex max-w-6xl flex-wrap items-center justify-between gap-4 px-6 py-4">
      <div class="flex flex-col gap-1">
        <p class="text-xs uppercase tracking-[0.2em] text-slate-500">Bridge Toolkit</p>
        <div class="flex items-center gap-3">
          <h1 class="text-2xl font-bold tracking-tight text-slate-900">Truss Joint Designer</h1>
        </div>
        <p class="text-sm text-slate-600">Single-page export tool for crisp, publication-ready joint diagrams.</p>
      </div>
      <div class="flex flex-wrap gap-2">
        <button id="exportJpegBtn" class="rounded-xl bg-brand-600 px-4 py-2 text-sm font-semibold text-white shadow-lg shadow-brand-600/30 ring-1 ring-brand-500 transition hover:-translate-y-0.5 hover:bg-brand-500">Export JPEGs</button>
        <button id="exportSvgBtn" class="rounded-xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5">Export SVG</button>
        <button id="exportZipBtn" class="rounded-xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5">Export ZIP</button>
        <button id="clearBtn" class="rounded-xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5">Reset</button>
      </div>
    </div>
  </header>

  <main class="mx-auto grid w-full max-w-6xl flex-1 grid-cols-1 gap-8 px-6 py-10 items-start">
    <section class="rounded-3xl border border-white/80 bg-white/90 shadow-2xl shadow-slate-200/60 ring-1 ring-slate-100 backdrop-blur">
      <div class="flex flex-col gap-8 p-8">
        <div class="flex flex-col gap-3">
          <div class="flex items-center justify-between gap-4">
            <div>
              <p class="text-xs font-semibold uppercase tracking-[0.24em] text-slate-500">Joint</p>
              <h2 class="text-lg font-semibold text-slate-900">Identity & switching</h2>
            </div>
            <div class="flex flex-wrap items-center gap-2">
              <div id="jointTabs" class="flex flex-wrap gap-2"></div>
              <button id="addJointBtn" class="rounded-lg border border-slate-200 bg-slate-50 px-3 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5" title="Add another joint to this truss">+ Joint</button>
            </div>
          </div>
          <div class="grid gap-3 md:grid-cols-1">
            <label class="flex flex-col gap-2 rounded-2xl border border-slate-200 bg-slate-50/70 p-4 shadow-inner shadow-slate-100">
              <span class="text-sm font-semibold text-slate-800">Joint name</span>
              <input id="jointName" type="text" placeholder="A" maxlength="6" class="w-full rounded-xl border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-sm focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200" />
              <span class="text-xs text-slate-500">Freeform labels sync across exports without forcing uppercase.</span>
            </label>
          </div>
        </div>

        <div class="rounded-2xl border border-slate-200 bg-slate-50/70 p-6 shadow-inner shadow-slate-100">
          <div class="flex flex-wrap items-center justify-between gap-3">
            <div class="space-y-1">
              <p class="text-xs font-semibold uppercase tracking-[0.24em] text-slate-500">Members</p>
              <h3 class="text-lg font-semibold text-slate-900">Direction & loading</h3>
              <p class="text-sm text-slate-600">Add as many members as needed for this joint. Quick-pick directions keep spacing aligned.</p>
            </div>
            <div class="rounded-full border border-slate-200 bg-white px-4 py-2 text-xs text-slate-600 shadow-sm">Tension → green · Compression → blue · Reaction → red</div>
          </div>

          <div id="memberList" class="mt-4 flex flex-col gap-4"></div>

          <div class="mt-2 flex flex-wrap items-center gap-2">
            <button id="addMemberBtn" class="rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5">+ Add member</button>
            <span class="text-xs text-slate-500">Members stay grouped per joint so nothing shifts while you work.</span>
          </div>
        </div>

        <div class="rounded-2xl border border-dashed border-slate-200 bg-slate-50/80 p-5 shadow-sm">
          <div class="flex flex-col gap-3">
            <div class="flex items-center gap-3">
              <span class="inline-flex h-10 w-10 items-center justify-center rounded-xl bg-brand-50 text-brand-600">⇪</span>
              <div>
                <p class="text-sm font-semibold text-slate-800">Optional batch import</p>
                <p class ="text-sm text-slate-600">Format: Joint, Member, Direction, Load Type, Load Value</p>
                <p class="text-sm text-slate-600">Paste or upload a structure file—every member is grouped with its joint.</p>
              </div>
            </div>
            <textarea id="structureText" class="w-full min-h-[120px] rounded-xl border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-inner shadow-slate-100 focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200" placeholder="A,AB,0,Tension,50
A,AC,45,Compression,30
B,BA,180,Reaction,18"></textarea>
            <div class="flex flex-wrap items-center gap-2">
              <button id="applyStructureBtn" class="rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5">Apply structure</button>
              <button id="importFileBtn" class="rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5" title="Import structure from JSON/CSV">Import file</button>
              <input type="file" id="importFile" accept=".json,.csv,.txt" class="hidden" />
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="relative rounded-3xl border border-white/80 bg-gradient-to-b from-white to-slate-50 p-5 shadow-2xl shadow-slate-200/60 ring-1 ring-slate-100">
      <div class="flex items-center justify-between px-1 pb-3">
        <div>
          <p class="text-xs font-semibold uppercase tracking-[0.24em] text-slate-500">Preview</p>
          <h2 class="text-lg font-semibold text-slate-900">Live canvas</h2>
        </div>
        <div class="flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1 text-xs text-slate-600 shadow-sm">
          <span class="inline-flex items-center gap-2"><span class="h-1 w-5 rounded-full bg-emerald-600"></span> Tension</span>
          <span class="inline-flex items-center gap-2"><span class="h-1 w-5 rounded-full bg-blue-600"></span> Compression</span>
          <span class="inline-flex items-center gap-2"><span class="h-1 w-5 rounded-full bg-red-600"></span> Reaction</span>
          <span class="inline-flex items-center gap-2"><span class="h-1 w-5 rounded-full bg-slate-500"></span> Direction only</span>
        </div>
      </div>
      <canvas id="cnv" width="1400" height="950" aria-label="diagram canvas" class="overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-inner shadow-slate-100"></canvas>
    </section>
  </main>

<script>
(() => {
  const $ = (sel, el=document) => el.querySelector(sel);
  const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));

  const cnv = $('#cnv');
  const ctx = cnv.getContext('2d');
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  function fitCanvas() {
    const w = cnv.clientWidth;
    const h = cnv.clientHeight;
    cnv.width = Math.round(w * DPR);
    cnv.height = Math.round(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    draw();
  }
  new ResizeObserver(fitCanvas).observe(cnv);

  const memberList = $('#memberList');
  const addMemberBtn = $('#addMemberBtn');
  const exportJpegBtn = $('#exportJpegBtn');
  const exportSvgBtn = $('#exportSvgBtn');
  const exportZipBtn = $('#exportZipBtn');
  const clearBtn = $('#clearBtn');
  const jointInput = $('#jointName');
  const jointTabs = $('#jointTabs');
  const addJointBtn = $('#addJointBtn');
  const structureText = $('#structureText');
  const applyStructureBtn = $('#applyStructureBtn');
  const importFileBtn = $('#importFileBtn');
  const importFileInput = $('#importFile');

  const truss = new Map();
  let currentJoint = 'A';
  let lastRender = null; // geometry and bbox for exports

  const escAttr = (val='') => String(val ?? '').replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

  function updateJointTabs(){
    jointTabs.innerHTML = '';
    for(const [name] of truss){
      const btn = document.createElement('button');
      btn.className = (name === currentJoint)
        ? 'rounded-lg border border-brand-200 bg-brand-50 px-3 py-2 text-sm font-semibold text-brand-700 shadow-sm ring-1 ring-brand-200 transition'
        : 'rounded-lg border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-800 shadow-sm transition hover:-translate-y-0.5';
      btn.textContent = name;
      btn.title = `Switch to joint ${name}`;
      btn.addEventListener('click', () => switchJoint(name));
      jointTabs.appendChild(btn);
    }
  }

  function createMemberRow(data={}, idx=0){
    const row = document.createElement('div');
    row.className = 'member-row rounded-2xl border border-slate-200 bg-white/90 p-5 shadow-sm ring-1 ring-white/70';
    row.innerHTML = `
      <div class="flex flex-wrap items-center justify-between gap-3 pb-2">
        <div class="flex items-center gap-2">
          <span class="member-index rounded-full bg-brand-50 px-3 py-1 text-xs font-semibold text-brand-700">Member ${idx+1}</span>
          <span class="text-sm font-semibold text-slate-800">Orientation & load</span>
        </div>
        <button type="button" class="remove-member rounded-lg border border-slate-200 bg-slate-50 px-2.5 py-1.5 text-xs font-semibold text-slate-600 shadow-sm transition hover:-translate-y-0.5">Remove</button>
      </div>
      <div class="grid grid-cols-1 gap-4 md:grid-cols-[minmax(200px,1fr)_minmax(360px,1.2fr)_minmax(260px,1.05fr)_minmax(220px,1fr)] md:items-start lg:grid-cols-[minmax(240px,1.05fr)_minmax(420px,1.25fr)_minmax(280px,1.05fr)_minmax(240px,1fr)]">
        <label class="flex flex-col gap-2">
          <span class="text-sm font-semibold text-slate-800">Member name</span>
          <input type="text" value="${escAttr(data.name || '')}" placeholder="AB" class="member-name w-full rounded-xl border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-sm focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200" />
        </label>
        <div class="flex flex-col gap-2">
          <div class="flex items-center justify-between text-sm font-semibold text-slate-800">
            <span>Direction (°)</span>
            <span class="text-xs font-medium text-slate-500">Quick picks</span>
          </div>
          <div class="grid grid-cols-2 gap-2 rounded-2xl border border-slate-200 bg-white p-4 shadow-sm md:grid-cols-[minmax(120px,0.9fr)_minmax(1fr,2fr)]">
            <input type="number" step="0.1" min="0" max="360" value="${escAttr((data.dir ?? '') === null ? '' : (data.dir ?? ''))}" class="member-dir col-span-2 rounded-lg border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-inner shadow-slate-100 focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200 md:col-span-1" placeholder="0 → right" />
            <!-- quick-pick arrows removed from this column and moved under Magnitude input -->
          </div>
        </div>
        <label class="flex flex-col gap-2">
          <span class="text-sm font-semibold text-slate-800">Sense / type</span>
          <select class="member-sense w-full rounded-xl border border-slate-200 px-3 py-2 text-sm font-semibold text-slate-900 shadow-inner shadow-slate-100 focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200">
            <option value="" ${!data.sense ? 'selected' : ''}>— direction only —</option>
            <option value="Tension" ${data.sense==='Tension'?'selected':''}>Tension (green)</option>
            <option value="Compression" ${data.sense==='Compression'?'selected':''}>Compression (blue)</option>
            <option value="Reaction" ${data.sense==='Reaction'?'selected':''}>Reaction (red)</option>
          </select>
          <span class="text-xs text-slate-500">Arrows flip automatically for compression and reaction.</span>
        </label>
        <label class="flex flex-col gap-2">
          <span class="text-sm font-semibold text-slate-800">Magnitude (kN)</span>
          <input type="number" step="0.01" value="${escAttr((data.magStr !== undefined ? data.magStr : (data.mag ?? '')) ?? '')}" class="member-mag w-full rounded-xl border border-slate-200 px-3 py-2 text-sm font-medium text-slate-900 shadow-inner shadow-slate-100 focus:border-brand-400 focus:outline-none focus:ring-2 focus:ring-brand-200" placeholder="e.g., 64.94" />
          <div class="grid grid-cols-4 gap-1 mt-2">
            <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="0" title="Right">→</button>
            <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="45" title="NE">↗</button>
            <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="90" title="Up">↑</button>
            <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="135" title="NW">↖</button>
            <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="180" title="Left">←</button>
            <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="225" title="SW">↙</button>
            <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="270" title="Down">↓</button>
            <button class="dirbtn rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-sm font-semibold text-slate-700 shadow-sm" data-deg="315" title="SE">↘</button>
          </div>
          <span class="text-xs text-slate-500">Shown over the member line when provided.</span>
        </label>
      </div>
    `;
    return row;
  }

  function updateMemberRowStates(){
    const rows = $$('.member-row', memberList);
    rows.forEach((row, idx) => {
      const badge = row.querySelector('.member-index');
      if(badge) badge.textContent = `Member ${idx+1}`;
      const remove = row.querySelector('.remove-member');
      if(remove){
        const lock = rows.length === 1;
        remove.disabled = lock;
        remove.classList.toggle('opacity-50', lock);
        remove.classList.toggle('cursor-not-allowed', lock);
      }
    });
  }

  function loadMembers(list){
    memberList.innerHTML = '';
    const source = Array.isArray(list) && list.length ? list : [{name:'AB', dir:45}];
    source.forEach((m, idx) => memberList.appendChild(createMemberRow(m, idx)));
    updateMemberRowStates();
  }

  function addMemberRow(data={}){
    memberList.appendChild(createMemberRow(data, memberList.children.length));
    updateMemberRowStates();
  }

  function saveCurrentJoint(){
    const members = getMembers();
    truss.set(currentJoint, members);
  }

  function switchJoint(name){
    const target = sanitizeJointName(name);
    saveCurrentJoint();
    currentJoint = target;
    jointInput.value = target;
    loadMembers(truss.get(target));
    updateJointTabs();
    draw();
  }

  function addJoint(name=''){ 
    const clean = sanitizeJointName(name || `J${truss.size+1}`);
    if(!truss.has(clean)){
      truss.set(clean, []);
    }
    switchJoint(clean);
  }

  function resetToSingleJoint(){
    truss.clear();
    currentJoint = 'A';
    truss.set(currentJoint, []);
    jointInput.value = currentJoint;
    loadMembers([{name:'AB', dir:45}]);
    saveCurrentJoint();
    updateJointTabs();
    draw();
  }

  function sanitizeJointName(name){
    const val = (name || '').trim();
    return val || 'A';
  }

  function getMembers(){
    const joint = sanitizeJointName(jointInput.value || currentJoint);
    const rows = $$('.member-row', memberList);
    const members = [];
    for(const row of rows){
      const name = row.querySelector('.member-name')?.value.trim().toUpperCase() || '';
      const dirVal = row.querySelector('.member-dir')?.value;
      const dir = dirVal === '' || dirVal === undefined ? null : parseFloat(dirVal);
      const sense = row.querySelector('.member-sense')?.value || '';
      const magStr = (row.querySelector('.member-mag')?.value || '').trim();
      const mag = magStr === '' ? null : parseFloat(magStr);
      if(!name && dir===null && !sense && mag===null && magStr==='') continue;
      members.push({
        name,
        dir: (dir!==null && Number.isFinite(dir)) ? dir : null,
        sense,
        mag: (mag!==null && Number.isFinite(mag)) ? mag : null,
        magStr,
        joint
      });
    }
    return members;
  }

  function parseStructure(text){
    const res = new Map();
    const raw = (text || '').trim();
    if(!raw) return res;
    try{
      const data = JSON.parse(raw);
      if(Array.isArray(data)){
        for(const entry of data){
          const j = sanitizeJointName(entry.joint || entry.name || '');
          if(!j) continue;
          const members = Array.isArray(entry.members) ? entry.members.map(m => ({
            name:(m.name||'').toString().toUpperCase(),
            dir: m.dir===null||m.dir===undefined?null:Number(m.dir),
            sense: m.sense||m.type||'',
            mag: m.mag===null||m.mag===undefined?null:Number(m.mag),
            magStr: m.mag===null||m.mag===undefined? '': String(m.mag)
          })) : [];
          res.set(j, members);
        }
      }
      if(res.size) return res;
    }catch(e){ /* fall back to line parser */ }

    const lines = raw.split(/\r?\n/);
    for(const p of labels){
      c.save();
      c.translate(p.x, p.y);
      c.rotate(-(p.rot || 0));
      const fontMatch = /(\d+)px/.exec(p.font||'16px');
      const fSize = fontMatch ? Number(fontMatch[1]) : 16;
      c.font = `${fSize}px "Times New Roman", Times, serif`;
      c.textAlign = 'center';
      c.textBaseline = 'middle';
      if(p.halo){
        c.lineWidth = 4;
        c.strokeStyle = '#ffffff';
        c.strokeText(p.text, 0, 0);
      }
      c.globalAlpha = p.alpha ?? 1;
      c.fillStyle = p.color || '#000';
      c.fillText(p.text, 0, 0);
      c.globalAlpha = 1;
      c.restore();
    }
  }

  function applyStructure(res){
    if(!res || !res.size) return;
    saveCurrentJoint();
    truss.clear();
    for(const [j, members] of res){
      const cleanMembers = Array.isArray(members) ? members.map(m => ({
        name:(m.name||'').toString().toUpperCase(),
        dir: m.dir===null||m.dir===undefined?null:Number(m.dir),
        sense: m.sense||m.type||'',
        mag: m.mag===null||m.mag===undefined?null:Number(m.mag),
        magStr: m.magStr ?? (m.mag===null||m.mag===undefined? '' : String(m.mag)),
        joint: sanitizeJointName(j)
      })) : [];
      truss.set(sanitizeJointName(j), cleanMembers);
    }
    const first = res.keys().next().value || 'A';
    switchJoint(first);
  }

  function clearCanvas(){
    const w = cnv.width / DPR;
    const h = cnv.height / DPR;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,cnv.width,cnv.height);
    ctx.restore();
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,w,h);
  }

  // geometry helpers
  function expandBBox(b, x, y){ b.minX = Math.min(b.minX, x); b.minY = Math.min(b.minY, y); b.maxX = Math.max(b.maxX, x); b.maxY = Math.max(b.maxY, y); }
  function expandRect(b, cx, cy, w, h, rot){
    const hw = w/2, hh = h/2;
    const c = Math.cos(-rot||0), s = Math.sin(-rot||0);
    const pts = [[-hw,-hh],[hw,-hh],[hw,hh],[-hw,hh]];
    for(const [dx,dy] of pts){
      const x = cx + c*dx - s*dy;
      const y = cy + s*dx + c*dy;
      expandBBox(b, x, y);
    }
  }

  function drawArrow(x1,y1,x2,y2, color, headAtEnd=true, b=null, c=ctx){
    // line
    c.strokeStyle = color;
    c.lineWidth = 3;
    c.lineCap = 'round';
    c.beginPath();
    c.moveTo(x1,y1);
    c.lineTo(x2,y2);
    c.stroke();
    if(b){ expandBBox(b, x1, y1); expandBBox(b, x2, y2); }
    // arrow head (larger)
    const ang = Math.atan2(y2 - y1, x2 - x1);
    const size = 14;
    const hx = headAtEnd ? x2 : x1;
    const hy = headAtEnd ? y2 : y1;
    const theta = headAtEnd ? ang : ang + Math.PI;

    c.beginPath();
    c.moveTo(hx, hy);
    const p1 = [hx - size * Math.cos(theta - Math.PI/7), hy - size * Math.sin(theta - Math.PI/7)];
    const p2 = [hx - size * Math.cos(theta + Math.PI/7), hy - size * Math.sin(theta + Math.PI/7)];
    c.lineTo(...p1);
    c.lineTo(...p2);
    c.closePath();
    c.fillStyle = color;
    c.fill();
    if(b){ expandBBox(b, hx, hy); expandBBox(b, p1[0], p1[1]); expandBBox(b, p2[0], p2[1]); }
  }

  function distancePointToSegment(px,py, x1,y1,x2,y2){
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A*C + B*D;
    const len_sq = C*C + D*D;
    let param = -1;
    if (len_sq !== 0) param = dot / len_sq;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function measure(text, font){
    ctx.save();
    ctx.font = font;
    const w = ctx.measureText(text).width;
    ctx.restore();
    return {w, h: 16};
  }

  function projAlong(px,py, x1,y1, ux,uy){
    return ( (px - x1) * ux + (py - y1) * uy );
  }

  function draw(){
    clearCanvas();
    const w = cnv.width / DPR;
    const h = cnv.height / DPR;
    const cx = Math.round(w*0.62);
    const cy = Math.round(h*0.50);

    const joint = sanitizeJointName(jointInput.value || currentJoint);
    if(!(jointInput.value || '').trim()){
      jointInput.value = joint;
    }
    const L = Math.min(w,h) * 0.28;

    const style = getComputedStyle(document.documentElement);
    const colors = {
      'Tension': style.getPropertyValue('--green').trim(),
      'Compression': style.getPropertyValue('--blue').trim(),
      'Reaction': style.getPropertyValue('--red').trim(),
      'Guide': '#8a8f9e'
    };

    const members = getMembers();

    const segments = []; // for exports
    const labels = [];   // for exports
    const bbox = {minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity};

    const END_MARGIN = 24; // min distance of magnitude text from both ends

    function rectHitsPlaced(x,y,tw,th){
      const r = Math.hypot(tw, th) * 0.48;
      for(const p of labels){
        const rp = Math.hypot(p.tw, p.th) * 0.48;
        const d = Math.hypot(x - p.x, y - p.y);
        if(d < r + rp + 2) return true;
      }
      return false;
    }
    function candidateHitsSegments(x,y,tw,th, angle, along, allowOverlap){
      if(allowOverlap) return false; // allow over-the-line for magnitudes
      for(const s of segments){
        const d = distancePointToSegment(x, y, s.x1, s.y1, s.x2, s.y2);
        const threshold = along ? Math.max(th/2 + 8, 14) : Math.max(Math.hypot(tw,th)*0.50, 9);
        if(d < threshold) return true;
      }
      return false;
    }
    function tooCloseToEnds(x,y,tw,th, seg){
      const half = tw/2;
      const pr = projAlong(x,y, seg.x1, seg.y1, seg.ux, seg.uy);
      return (pr - half) < END_MARGIN || (pr + half) > (seg.L - END_MARGIN);
    }

    function putNearPoint(text, baseX, baseY, opts={}){
      const font = `${opts.size||16}px "Times New Roman", Times, serif`;
      const m = measure(text, font);
      const tw = m.w, th = m.h;
      const radii = opts.radii || [0,2,4,6,8,12,16];
      const dirs = opts.dirs || [0,45,90,135,180,225,270,315];
      for(const r of radii){
        for(const d of dirs){
          const a = d*Math.PI/180;
          const x = baseX + r*Math.cos(a);
          const y = baseY - r*Math.sin(a);
          if(!candidateHitsSegments(x,y,tw,th, 0, false, false) && !rectHitsPlaced(x,y,tw,th)){
            const obj = {x,y,tw,th,rot:0, color:opts.color||'#000', font, text, alpha: 1, halo:false};
            labels.push(obj);
            expandRect(bbox, obj.x, obj.y, tw+4, th+4, obj.rot);
            return obj;
          }
        }
      }
      const obj = {x:baseX,y:baseY,tw,th,rot:0, color:opts.color||'#000', font, text, alpha: 1, halo:false};
      labels.push(obj);
      expandRect(bbox, obj.x, obj.y, tw+4, th+4, obj.rot);
      return obj;
    }

    function putLabel(text, baseX, baseY, opts={angle:0, color:'#000', size:16, alignAlong:false, nearPoint:false, seg:null, minNormal:null, halo:false, alpha:1, overLine:false}){
      if(opts.nearPoint) return putNearPoint(text, baseX, baseY, opts);
      const font = `${opts.size||16}px "Times New Roman", Times, serif`;
      const m = measure(text, font);
      const tw = m.w, th = m.h;

      const tries = [];
      if(opts.alignAlong){
        const ang = opts.angle || 0;
        const ux = Math.cos(ang), uy = Math.sin(ang);
        const nx = -Math.sin(ang), ny = Math.cos(ang);
        const minP = Math.max(opts.minNormal ?? 0, 0); // allow being on the line
        for(let p=minP; p<=minP+8; p+=2){       // stay right on or near the line
          for(let s=0; s<=36; s+=6){            // small slides along
            tries.push([baseX + ux*s + nx*p, baseY - uy*s + ny*p, ang, true]);
            if(s>0) tries.push([baseX - ux*s + nx*p, baseY + uy*s + ny*p, ang, true]);
          }
        }
      }else{
        const radii = [0,2,4,6,8,12];
        const dirs = [0,45,90,135,180,225,270,315];
        for(const r of radii){
          for(const d of dirs){
            const a = d*Math.PI/180;
            tries.push([baseX + r*Math.cos(a), baseY - r*Math.sin(a), 0, false]);
          }
        }
      }
      for(const [x,y,rot,along] of tries){
        if(opts.seg && along && tooCloseToEnds(x,y,tw,th, opts.seg)) continue;
        if(!candidateHitsSegments(x,y,tw,th, rot, along, opts.overLine) && !rectHitsPlaced(x,y,tw,th)){
          const obj = {x,y,tw,th,rot, color:opts.color, font, text, halo: !!opts.halo, alpha: opts.alpha ?? 1};
          labels.push(obj);
          const haloPad = obj.halo ? 4 : 0;
          expandRect(bbox, obj.x, obj.y, tw+haloPad, th+haloPad, obj.rot);
          return obj;
        }
      }
      const obj = {x:baseX,y:baseY,tw,th,rot:opts.angle||0, color:opts.color, font, text, halo: !!opts.halo, alpha: opts.alpha ?? 1};
      labels.push(obj);
      const haloPad = obj.halo ? 4 : 0;
      expandRect(bbox, obj.x, obj.y, tw+haloPad, th+haloPad, obj.rot);
      return obj;
    }

    // Draw members and labels
    const JOINT = {x: cx, y: cy};
    for(const m of members){
      if(m.dir === null) continue;
      const rad = (m.dir % 360) * Math.PI/180;
      const x2 = cx + L*Math.cos(rad);
      const y2 = cy - L*Math.sin(rad);
      const ux = Math.cos(rad), uy = -Math.sin(rad); // canvas y inverted
      const nx = -Math.sin(rad), ny = Math.cos(rad);

      const seg = {x1:cx, y1:cy, x2, y2, ux, uy, L, color:colors[m.sense] || '#8a8f9e', dashed: !m.sense, headAtEnd: !(m.sense === 'Compression' || m.sense === 'Reaction')};

      // store for export
      segments.push(seg);

      // draw
      if(!m.sense){
        ctx.strokeStyle = 'rgba(120,120,130,.5)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6,6]);
        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.lineTo(x2,y2);
        ctx.stroke();
        ctx.setLineDash([]);
        expandBBox(bbox, cx, cy); expandBBox(bbox, x2, y2);
      } else {
        drawArrow(cx, cy, x2, y2, seg.color, seg.headAtEnd, bbox);
      }

      // Far-end node letter
      const name = (m.name||'').replace(/[^A-Z]/g,'').toUpperCase();
      if(name){
        const letters = name.split('');
        const other = letters.find(ch => ch !== m.joint) || name;
        const tipx = cx + L*ux, tipy = cy + L*uy;
        const fx = tipx + nx*10;
        const fy = tipy + ny*10;
        putLabel(other, fx, fy, {size:16, color:'#000', nearPoint:true});
      }

      // Magnitude label (over the line)
      if(m.magStr && m.magStr.length && m.sense){
        const frac = 0.62;
        const base = { x: cx + (L*frac)*ux, y: cy + (L*frac)*uy };
        const obj = putLabel(`${m.magStr} kN`, base.x, base.y, {
          angle: rad,
          color: colors[m.sense],
          size: 16,
          alignAlong: true,
          seg,
          overLine: true,
          halo: true,
          alpha: 0.92
        });
        obj.rot = (Math.cos(rad) < 0) ? (rad + Math.PI) : rad;
      }
    }

    // Joint node + label
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI*2);
    ctx.fill();
    expandBBox(bbox, cx-4, cy-4); expandBBox(bbox, cx+4, cy+4);

    putNearPoint((joint||'A'), cx, cy, {
      size:16, color:'#000',
      radii:[8,10,12,14,16,18,20],
      dirs:[0,45,315,90,270,135,225,180]
    });

    // Render labels on top
    for(const p of labels){
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(-(p.rot || 0));
      ctx.font = p.font || '16px "Times New Roman", Times, serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      if(p.halo){
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#ffffff';
        ctx.strokeText(p.text, 0, 0);
      }
      ctx.globalAlpha = p.alpha ?? 1;
      ctx.fillStyle = p.color || '#000';
      ctx.fillText(p.text, 0, 0);
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // Save render info for exports
    const PAD = 12;
    const minX = Math.max(0, Math.floor(bbox.minX - PAD));
    const minY = Math.max(0, Math.floor(bbox.minY - PAD));
    const maxX = Math.min(w, Math.ceil(bbox.maxX + PAD));
    const maxY = Math.min(h, Math.ceil(bbox.maxY + PAD));
    lastRender = {
      width: w, height: h, bbox:{x:minX,y:minY,w:Math.max(4,maxX-minX),h:Math.max(4,maxY-minY)},
      segments, labels, joint: JOINT, colors
    };
  }

  // ----- EXPORTS -----
  function downloadDataURI(name, dataURI){
    const link = document.createElement('a');
    link.download = name;
    link.href = dataURI;
    document.body.appendChild(link);
    link.click();
    link.remove();
  }

  function renderJpegDataURI(name){
    const safeName = (name || 'joint').trim() || 'joint';
    if(!lastRender){ draw(); }
    const SCALE = 4; // 4x size
    const {bbox, segments, labels, joint} = lastRender;

    const off = document.createElement('canvas');
    const PX = Math.max(1, Math.round(bbox.w * SCALE * DPR));
    const PY = Math.max(1, Math.round(bbox.h * SCALE * DPR));
    off.width = PX; off.height = PY;
    const c = off.getContext('2d');
    c.fillStyle = '#ffffff';
    c.fillRect(0,0,PX,PY);
    c.setTransform(DPR*SCALE, 0, 0, DPR*SCALE, -bbox.x*DPR*SCALE, -bbox.y*DPR*SCALE);

    c.lineCap = 'round';
    for(const s of segments){
      if(s.dashed){
        c.strokeStyle = 'rgba(120,120,130,.5)';
        c.lineWidth = 1.5;
        c.setLineDash([6,6]);
        c.beginPath();
        c.moveTo(s.x1,s.y1);
        c.lineTo(s.x2,s.y2);
        c.stroke();
        c.setLineDash([]);
      }else{
        drawArrow(s.x1,s.y1,s.x2,s.y2, s.color, s.headAtEnd, null, c);
      }
    }
    c.fillStyle = '#000';
    c.beginPath();
    c.arc(joint.x, joint.y, 4, 0, Math.PI*2);
    c.fill();

    for(const p of labels){
      c.save();
      c.translate(p.x, p.y);
      c.rotate(-(p.rot || 0));
      const fontSize = /(\d+)px/.exec(p.font||'16px')?.[1] || 16;
      c.font = `${fontSize}px "Times New Roman", Times, serif`;
      c.textAlign = 'center';
      c.textBaseline = 'middle';
      if(p.halo){
        c.lineWidth = 4;
        c.strokeStyle = '#ffffff';
        c.strokeText(p.text, 0, 0);
      }
      c.globalAlpha = p.alpha ?? 1;
      c.fillStyle = p.color || '#000';
      c.fillText(p.text, 0, 0);
      c.globalAlpha = 1;
      c.restore();
    }

    return {name: safeName, dataURI: off.toDataURL('image/jpeg', 1.0)};
  }

  // Render a PNG data URI at export scale. Similar to `renderJpegDataURI`
  function renderPngDataURI(name){
    const safeName = (name || 'joint').trim() || 'joint';
    if(!lastRender){ draw(); }
    const SCALE = 4; // 4x size
    const {bbox, segments, labels, joint} = lastRender;

    const off = document.createElement('canvas');
    const PX = Math.max(1, Math.round(bbox.w * SCALE * DPR));
    const PY = Math.max(1, Math.round(bbox.h * SCALE * DPR));
    off.width = PX; off.height = PY;
    const c = off.getContext('2d');
    c.fillStyle = '#ffffff';
    c.fillRect(0,0,PX,PY);
    c.setTransform(DPR*SCALE, 0, 0, DPR*SCALE, -bbox.x*DPR*SCALE, -bbox.y*DPR*SCALE);

    c.lineCap = 'round';
    for(const s of segments){
      if(s.dashed){
        c.strokeStyle = 'rgba(120,120,130,.5)';
        c.lineWidth = 1.5;
        c.setLineDash([6,6]);
        c.beginPath();
        c.moveTo(s.x1,s.y1);
        c.lineTo(s.x2,s.y2);
        c.stroke();
        c.setLineDash([]);
      }else{
        drawArrow(s.x1,s.y1,s.x2,s.y2, s.color, s.headAtEnd, null, c);
      }
    }
    c.fillStyle = '#000';
    c.beginPath();
    c.arc(joint.x, joint.y, 4, 0, Math.PI*2);
    c.fill();

    for(const p of labels){
      c.save();
      c.translate(p.x, p.y);
      c.rotate(-(p.rot || 0));
      const fontMatch = /(\d+)px/.exec(p.font||'16px');
      const fSize = fontMatch ? Number(fontMatch[1]) : 16;
      c.font = `${fSize}px "Times New Roman", Times, serif`;
      c.textAlign = 'center';
      c.textBaseline = 'middle';
      if(p.halo){
        c.lineWidth = 4;
        c.strokeStyle = '#ffffff';
        c.strokeText(p.text, 0, 0);
      }
      c.globalAlpha = p.alpha ?? 1;
      c.fillStyle = p.color || '#000';
      c.fillText(p.text, 0, 0);
      c.globalAlpha = 1;
      c.restore();
    }

    return {name: safeName, dataURI: off.toDataURL('image/png')};
  }

  function exportAllJpegs(){
    saveCurrentJoint();
    const original = currentJoint;
    if(!truss.size){ truss.set(currentJoint, getMembers()); }
    const renders = [];
    for(const [name] of truss){
      switchJoint(name);
      renders.push(renderJpegDataURI(name));
    }
    switchJoint(original);

    if(renders.length === 1){
      const single = renders[0];
      downloadDataURI(`${single.name}.jpg`, single.dataURI);
      return;
    }

    const files = renders.map(r => ({ name: `${r.name}.jpg`, bytes: dataUriToBytes(r.dataURI) }));
    const zipBlob = buildZip(files);
    downloadBlob('truss-joints-jpegs.zip', zipBlob);
  }

  function buildSvgString(name){
    const safeName = (name || 'joint').trim() || 'joint';
    if(!lastRender){ draw(); }
    const {bbox, segments, labels, joint} = lastRender;

    function esc(s){return (''+s).replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[c]));}

    let svg = [];
    svg.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${bbox.w}" height="${bbox.h}" viewBox="${bbox.x} ${bbox.y} ${bbox.w} ${bbox.h}" font-family="Times New Roman, Times, serif">`);
    svg.push(`<defs>
      <marker id="arrowGreenEnd" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
        <path d="M 10 5 L 0 1 L 0 9 z" fill="#2e7d32" />
      </marker>
      <marker id="arrowBlueEnd" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
        <path d="M 10 5 L 0 1 L 0 9 z" fill="#1e88e5" />
      </marker>
      <marker id="arrowRedEnd" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto">
        <path d="M 10 5 L 0 1 L 0 9 z" fill="#c62828" />
      </marker>
      <marker id="arrowGreenStart" viewBox="0 0 10 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 5 L 10 1 L 10 9 z" fill="#2e7d32" />
      </marker>
      <marker id="arrowBlueStart" viewBox="0 0 10 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 5 L 10 1 L 10 9 z" fill="#1e88e5" />
      </marker>
      <marker id="arrowRedStart" viewBox="0 0 10 10" refX="0" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
        <path d="M 0 5 L 10 1 L 10 9 z" fill="#c62828" />
      </marker>
    </defs>`);

    function markerId(color, headAtEnd){
      if(color==='#2e7d32') return headAtEnd?'arrowGreenEnd':'arrowGreenStart';
      if(color==='#1e88e5') return headAtEnd?'arrowBlueEnd':'arrowBlueStart';
      if(color==='#c62828') return headAtEnd?'arrowRedEnd':'arrowRedStart';
      return null;
    }

    for(const s of segments){
      const dashed = s.dashed;
      const mk = markerId(s.color, s.headAtEnd);
      svg.push(`<path d="M ${s.x1} ${s.y1} L ${s.x2} ${s.y2}" fill="none" stroke="${esc(s.color)}" stroke-width="3" stroke-linecap="round" ${dashed?'stroke-dasharray="6 6"':''} ${mk? (s.headAtEnd?`marker-end="url(#${mk})"`:`marker-start="url(#${mk})"`) : ''} />`);
    }

    svg.push(`<circle cx="${joint.x}" cy="${joint.y}" r="4" fill="#000"/>`);

    for(const p of labels){
      const deg = -(p.rot||0) * 180/Math.PI;
      const fontSize = /(\d+)px/.exec(p.font||'16px')?.[1] || 16;
      if(p.halo){
        svg.push(`<text x="${p.x}" y="${p.y}" font-size="${fontSize}" text-anchor="middle" dominant-baseline="middle" fill="none" stroke="#ffffff" stroke-width="4" stroke-linejoin="round" stroke-linecap="round" transform="rotate(${deg} ${p.x} ${p.y})">${esc(p.text)}</text>`);
      }
      svg.push(`<text x="${p.x}" y="${p.y}" font-size="${fontSize}" text-anchor="middle" dominant-baseline="middle" fill="${esc(p.color||'#000')}" fill-opacity="${p.alpha??1}" transform="rotate(${deg} ${p.x} ${p.y})">${esc(p.text)}</text>`);
    }

    svg.push(`</svg>`);
    return {name: safeName, svg: svg.join('')};
  }

  exportJpegBtn.addEventListener('click', exportAllJpegs);

  exportSvgBtn.addEventListener('click', () => {
    const {name, svg} = buildSvgString(jointInput.value||'joint');
    const blob = new Blob([svg], {type:'image/svg+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name}.svg`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  });

  function dataUriToBytes(uri){
    const base64 = (uri.split(',')[1] || '').trim();
    const bin = atob(base64);
    const bytes = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return bytes;
  }

  const utf8 = new TextEncoder();
  function textToBytes(str){
    return utf8.encode(str);
  }

  const CRC32_TABLE = (() => {
    let c; const table = new Uint32Array(256);
    for(let n=0;n<256;n++){
      c = n;
      for(let k=0;k<8;k++) c = c & 1 ? 0xEDB88320 ^ (c>>>1) : c>>>1;
      table[n] = c >>> 0;
    }
    return table;
  })();

  function crc32(bytes){
    let crc = 0 ^ (-1);
    for(let i=0;i<bytes.length;i++){
      crc = (crc >>> 8) ^ CRC32_TABLE[(crc ^ bytes[i]) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
  }

  function dosDateTime(date=new Date()){
    const time = (date.getHours() << 11) | (date.getMinutes() << 5) | (date.getSeconds() >> 1);
    const dosDate = ((date.getFullYear() - 1980) << 9) | ((date.getMonth() + 1) << 5) | date.getDate();
    return {time, date: dosDate};
  }

  function buildZip(files){
    const parts = [];
    const central = [];
    let offset = 0;
    const records = [];

    for(const f of files){
      const nameBytes = textToBytes(f.name);
      const dataBytes = f.bytes instanceof Uint8Array ? f.bytes : textToBytes(String(f.bytes||''));
      const crc = crc32(dataBytes);
      const {time, date} = dosDateTime();
      const local = new Uint8Array(30 + nameBytes.length + dataBytes.length);
      const view = new DataView(local.buffer);
      view.setUint32(0, 0x04034b50, true);
      view.setUint16(4, 20, true);
      view.setUint16(6, 0, true);
      view.setUint16(8, 0, true); // store (no compression)
      view.setUint16(10, time, true);
      view.setUint16(12, date, true);
      view.setUint32(14, crc, true);
      view.setUint32(18, dataBytes.length, true);
      view.setUint32(22, dataBytes.length, true);
      view.setUint16(26, nameBytes.length, true);
      view.setUint16(28, 0, true);
      local.set(nameBytes, 30);
      local.set(dataBytes, 30 + nameBytes.length);
      parts.push(local);
      records.push({nameBytes, crc, size:dataBytes.length, offset, time, date});
      offset += local.length;
    }

    let centralSize = 0;
    for(const r of records){
      const cd = new Uint8Array(46 + r.nameBytes.length);
      const view = new DataView(cd.buffer);
      view.setUint32(0, 0x02014b50, true);
      view.setUint16(4, 0x14, true);
      view.setUint16(6, 20, true);
      view.setUint16(8, 0, true);
      view.setUint16(10, 0, true);
      view.setUint16(12, r.time, true);
      view.setUint16(14, r.date, true);
      view.setUint32(16, r.crc, true);
      view.setUint32(20, r.size, true);
      view.setUint32(24, r.size, true);
      view.setUint16(28, r.nameBytes.length, true);
      view.setUint16(30, 0, true);
      view.setUint16(32, 0, true);
      view.setUint16(34, 0, true);
      view.setUint16(36, 0, true);
      view.setUint32(38, 0, true);
      view.setUint32(42, r.offset, true);
      cd.set(r.nameBytes, 46);
      central.push(cd);
      centralSize += cd.length;
    }

    const end = new Uint8Array(22);
    const endView = new DataView(end.buffer);
    endView.setUint32(0, 0x06054b50, true);
    endView.setUint16(4, records.length, true);
    endView.setUint16(6, records.length, true);
    endView.setUint32(8, centralSize, true);
    endView.setUint32(12, offset, true);
    endView.setUint16(16, 0, true);
    endView.setUint16(18, 0, true);
    endView.setUint16(20, 0, true);

    return new Blob([...parts, ...central, end], {type:'application/zip'});
  }

  function downloadBlob(name, blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function exportAllAsZip(){
    saveCurrentJoint();
    const original = currentJoint;
    if(!truss.size){ truss.set(currentJoint, getMembers()); }
    const files = [];
    for(const [name] of truss){
      switchJoint(name);
      const jpeg = renderJpegDataURI(name);
      const png = renderPngDataURI(name);
      const svg = buildSvgString(name);
      files.push({name: `${jpeg.name}.jpg`, bytes: dataUriToBytes(jpeg.dataURI)});
      files.push({name: `${png.name}.png`, bytes: dataUriToBytes(png.dataURI)});
      files.push({name: `${svg.name}.svg`, bytes: textToBytes(svg.svg)});
    }
    switchJoint(original);
    const zipBlob = buildZip(files);
    downloadBlob('truss-joints.zip', zipBlob);
  }

  memberList.addEventListener('click', (e) => {
    const dirBtn = e.target.closest('.dirbtn');
    if(dirBtn){
      e.preventDefault();
      const row = dirBtn.closest('.member-row');
      if(row){
        const input = row.querySelector('.member-dir');
        if(input){ input.value = dirBtn.dataset.deg; }
        saveCurrentJoint();
        draw();
      }
      return;
    }
    const removeBtn = e.target.closest('.remove-member');
    if(removeBtn){
      e.preventDefault();
      const row = removeBtn.closest('.member-row');
      if(row && memberList.children.length > 1){
        row.remove();
        updateMemberRowStates();
        saveCurrentJoint();
        draw();
      }
    }
  });

  memberList.addEventListener('input', (e) => {
    if(e.target.matches('.member-name, .member-dir, .member-sense, .member-mag')){
      saveCurrentJoint();
      draw();
    }
  });
  memberList.addEventListener('change', (e) => {
    if(e.target.matches('.member-name, .member-dir, .member-sense, .member-mag')){
      saveCurrentJoint();
      draw();
    }
  });

  addMemberBtn.addEventListener('click', (e) => {
    e.preventDefault();
    addMemberRow();
    saveCurrentJoint();
    draw();
  });

  clearBtn.addEventListener('click', () => {
    loadMembers([]);
    saveCurrentJoint();
    draw();
  });

  jointInput.addEventListener('input', () => {
    const clean = sanitizeJointName(jointInput.value || currentJoint);
    if(clean && clean !== currentJoint){
      const members = getMembers();
      truss.delete(currentJoint);
      currentJoint = clean;
      truss.set(currentJoint, members);
      updateJointTabs();
    }
    draw();
  });

  addJointBtn.addEventListener('click', () => addJoint(`J${truss.size+1}`));

  applyStructureBtn.addEventListener('click', () => {
    const parsed = parseStructure(structureText.value);
    applyStructure(parsed);
  });

  importFileBtn.addEventListener('click', () => importFileInput.click());
  importFileInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if(!file) return;
    const text = await file.text();
    const parsed = parseStructure(text);
    applyStructure(parsed);
    importFileInput.value = '';
  });

  exportZipBtn.addEventListener('click', exportAllAsZip);

  // Initial state
  resetToSingleJoint();
  updateJointTabs();
  fitCanvas();
  draw();
})();
</script>
</body>
</html>
